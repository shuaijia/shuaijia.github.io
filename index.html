<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="贾帅的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Android机动车">
<meta property="og:url" content="http://shuaijia.github.io/index.html">
<meta property="og:site_name" content="Android机动车">
<meta property="og:description" content="贾帅的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android机动车">
<meta name="twitter:description" content="贾帅的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shuaijia.github.io/"/>





  <title>Android机动车</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/shuaijia"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Android机动车</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人之所以能，是相信能</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/02/09/和自己走走心——2017年总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/和自己走走心——2017年总结/" itemprop="url">和自己走走心——2017年总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-09T00:00:00+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>2017年，是自己毕业的第二年，也是从事Android开发第三年。每一年似乎一点都没察觉，就到了年底。尤其是在毕业之后，才深刻地感受到什么叫<strong>时光飞逝</strong>。</p>
<p>过完年会，正好手活儿不多，就安静地写写文章，整理一下这一年，和自己走走心。</p>
<p>如果用简单词语来总结这一年，我觉得应该是：<strong>平淡</strong>、<strong>学习</strong>。这一年，生活平平淡淡，有值得高兴的事，也有遇到一些“麻烦”。一年中，一直在不断地学习，不断地充电，写了很多文章，学习和尝试了许多新技术和新思路。</p>
<p>这一年或许可以更好，但是对我来说没有丝毫的遗憾。</p>
<h3 id="年初目标"><a href="#年初目标" class="headerlink" title="年初目标"></a>年初目标</h3><p>2016年，刚毕业，自己定了两个目标——<strong>减肥</strong>和<strong>涨薪</strong>，但只实现了一个。很值得骄傲的是，用了一个夏天的时间，成功减肥35斤，并且到现在也没有反弹^_^。</p>
<p>旧公司种种原因吧，工资拖欠，也是很多互联网创业公司常常发生的，但我依然很感恩，在自己还是个懵懂少年的时候，公司认可了我，在工作中学到了许多Android开发技巧，也学着如何与人交流沟通，认识了一帮交心的朋友。</p>
<p>但2017年年初实现了16年的第二个目标，换了工作，成功跻身西二旗程序猿大队中，从此，<strong>西二旗</strong>、<strong>软件园</strong>、<strong>后厂村路</strong>似乎离不开我的生活。</p>
<p>于是，2017年伊始，给自己制定了新的目标：</p>
<ul>
<li>学习</li>
<li>健身</li>
<li>旅游</li>
</ul>
<p>现在想来，这些小目标，似乎都做了。</p>
<h3 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h3><p>2016年，深感自己技术欠缺，所以2017年，一直在做的就是，学习新的技术，弥补自己的缺失。</p>
<p>这一年，买了本《大话数据结构》，每天晚上下班后去健身，回来大约十点，再学习回顾数据结构到十二点再收拾睡觉。还好不负苦心，自觉数据结构长进不少。</p>
<p>Android方面，学习尝试了许多新的东西，模块化开发、指纹登录、百度翻译、语音播报、代码混淆、银联支付、EventBus、Router方案、DataBinding、MVVM、AR等等，对自定义View熟悉了许多，也写了不少自定义的View。遇到新的需求，学会了分析和制定解决方案，直到一步步实现。</p>
<p>17年，用 <strong>Retrofit+RxJava+Glide+Gson+MVP</strong> 封装了一个开发框架，并在真实的工作中使用。在开发过程中也发现了框架的不足，并且一点点地完善、优化。春节过后，会抽时间将之提交github与大家分享。</p>
<p>尝试使用 <strong>MediaPlayer+SurfaceView</strong> 封装了视频播放器，并取名叫 <strong>JsPlayer</strong>（当然，Android播放器，和JavaScript没有关系了） ，github地址是<a href="https://github.com/shuaijia/JsPlayer" target="_blank" rel="noopener">https://github.com/shuaijia/JsPlayer</a>，已经获得40多个star，我知道这还远远不够，还会一直去优化和维护它。</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>自己是一个典型的理工男，文笔不好，之前也不喜欢写东西。但是后半年以来，受到朋友启发，写了许多技术相关的文章，都发到了掘金、CSDN、简书。向github提交了多个项目，学会了制作依赖库。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/161796c6f7631dee?w=750&amp;h=1334&amp;f=jpeg&amp;s=51531" alt="掘金"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/161796a40f5a3f47?w=293&amp;h=323&amp;f=png&amp;s=22693" alt="csdn"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/161796da58033e95?w=1038&amp;h=529&amp;f=png&amp;s=114442" alt="github"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/161796dcecc8bdc4?w=710&amp;h=441&amp;f=png&amp;s=26531" alt="github贡献"></p>
<p>掘金获得两千多收藏、近三万的阅读量；csdn写了近70篇文章；github共440个贡献，近两百个star。</p>
<p>九月份，开通了自己的微信公众号——<strong>Android机动车</strong>，截止目前已经发文95篇：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/161797559681f9e6?w=765&amp;h=343&amp;f=png&amp;s=23262" alt=""></p>
<p>自己从一个讨厌写文章的人，慢慢地开始喜欢写作，享受写作到给自己的成长。写博客，不仅整理自己的思路，也认识了许多志同道合的朋友，在这过程中，互相帮助、一起进步。</p>
<p>顺便也和大家分享：</p>
<blockquote>
<ul>
<li>掘金：<a href="https://juejin.im/user/5795730379bc44006638e28f" target="_blank" rel="noopener">https://juejin.im/user/5795730379bc44006638e28f</a></li>
<li>csdn: <a href="http://blog.csdn.net/jiashuai94" target="_blank" rel="noopener">http://blog.csdn.net/jiashuai94</a></li>
<li>github: <a href="https://github.com/shuaijia" target="_blank" rel="noopener">https://github.com/shuaijia</a></li>
<li>公众号：Android机动车</li>
</ul>
</blockquote>
<h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>新公司做的是在线教育，主攻方向依旧是视频播放。除了使用自己封装VideoView、MediaPlayer+SurfaceView之外，也了解和学习了IjkPlayer、Vitamio和ExoPlayer。</p>
<p>这一年工作中，曾建议项目进行代码混淆、热修复集成和接口版本开发，但种种原因，也没有推行下去。当然，也整理了不少工作相关文档。</p>
<p>不知不觉开始了主持的路子。又是一年年终，又操起了老本行，主持了前两天的公司年会。这次也是挑战了自己，连续九个小时，还参与了一个舞蹈和合唱，身心俱疲。自己也算是一个会敲代码的文艺工作者吧，哈哈。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/9/16179a884af4e77d?w=1080&amp;h=1440&amp;f=jpeg&amp;s=114321" alt=""></p>
<h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>年初曾计划，新一年，一定练出一身“腱子肉”，有一段时间，每天下班去健身，当然付出就有回报，咱也是有过腹肌的，嘿嘿；说到旅游，去了南京、苏州、上海、北戴河；2017年，让本是开车菜鸟的我，也慢慢变成了“老司机”，曾在四环绕了一次又一次。。。</p>
<p>这一年，收获很多，也麻烦不少，共享汽车被骗、被中介欺负。。但让自己庆幸的是，身边有一群交心的朋友，一直陪伴着，帮助着。经常出来喝喝酒、聊聊天，心里总是慰藉。</p>
<h3 id="诗和远方"><a href="#诗和远方" class="headerlink" title="诗和远方"></a>诗和远方</h3><p>新的一年，自己将依旧坚持学习，写文章，维护自己的博客和公众号；技术方面，希望自己对视频播放有更深的研究，对java底层、Android底层和优化更加深刻理解；坚持健身，锻炼好身体，做一个强壮的程序猿。。。</p>
<p>人生就在于不断超越自己，才有所进步。还记得第一次面对八百人去主持，心里是慌的，自己可以吗、能行吗？但多次主持下来，现在也能从容面对。人生的奔跑，不在于瞬间的爆发，取决于途中的坚持。纵有千百个理由放弃，也要找到一个理由坚持下去。</p>
<p>喜欢一首邓丽君的《漫步人生路》，<strong>目标推远，让理想永远在前面</strong>。勿忘初心，方得始终。</p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/02/08/Android-5-0以上系统常用控件着色指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/Android-5-0以上系统常用控件着色指南/" itemprop="url">Android5.0以上系统常用控件着色指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-08T00:00:00+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当我们新建一个项目的时候，都会给Application或者某些Activity设置theme：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme=&quot;@style/AppTheme&quot;</span><br></pre></td></tr></table></figure>
<p>这时就需要我们选择或者自定义一个主题，那每个属性又都是什么含义呢？</p>
<p>来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot;&gt;</span><br><span class="line">	&lt;!--主色调 --&gt;</span><br><span class="line">	&lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">	&lt;!--状态栏颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">	&lt;!--控制各个控件被选中时的颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">	&lt;!--页面背景色--&gt;</span><br><span class="line">	&lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorWindowBg&lt;/item&gt;</span><br><span class="line">	&lt;!--底部导航栏颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;android:navigationBarColor&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">	&lt;!--ToolBar上的Title颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/colorText&lt;/item&gt;</span><br><span class="line">	&lt;!--各个控制控件的默认颜色 与colorAccent相反--&gt;</span><br><span class="line">	&lt;item name=&quot;android:colorControlNormal&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">	&lt;!--控制所有可点击的View的涟漪效果颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;android:colorControlHighlight&quot;&gt;@color/colorCheck&lt;/item&gt;</span><br><span class="line">	&lt;!--控制normal状态下button的颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;android:colorButtonNormal&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">	&lt;!--EditText 输入框中字体的颜色--&gt;</span><br><span class="line">	&lt;item name=&quot;editTextColor&quot;&gt;@color/colorText&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>相关属性说明</p>
<ul>
<li>1.<strong>colorPrimary</strong>: Toolbar导航栏的底色。</li>
<li>2.<strong>colorPrimaryDark</strong>：状态栏的底色，注意这里只支持Android5.0以上的手机。</li>
<li>3.<strong>textColorPrimary</strong>：整个当前Activity的字体的默认颜色。</li>
<li>4.<strong>android:windowBackground</strong>：当前Activity的窗体颜色。</li>
<li>5.<strong>colorAccent</strong>：CheckBox，RadioButton，SwitchCompat等控件的点击选中颜色</li>
<li>6.<strong>colorControlNormal</strong>：CheckBox，RadioButton，SwitchCompat等默认状态的颜色。</li>
<li>7.<strong>colorButtonNormal</strong>：默认状态下Button按钮的颜色。</li>
<li>8.<strong>editTextColor</strong>：默认EditView输入框字体的颜色。</li>
</ul>
<h3 id="特别介绍"><a href="#特别介绍" class="headerlink" title="特别介绍"></a>特别介绍</h3><p>下面我们要说的是其他一些和颜色相关的属性，这些属性可能你平时并不常用，但合理运用它们不仅可以使你的界面更加绚丽而且可以达到事半功倍的效果。（再次声明以下属性适用于5.0及其以上系统）</p>
<h4 id="1、colorControlHighlight"><a href="#1、colorControlHighlight" class="headerlink" title="1、colorControlHighlight"></a>1、colorControlHighlight</h4><p>colorControlHighlight用于控制所有可点击的View的涟漪效果颜色，以button举例来说</p>
<p>普通状态下的button</p>
<p><img src="http://img.blog.csdn.net/20180207150427319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>现在我们在AppTheme中添加下面这条属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:colorControlHighlight&quot;&gt;@color/colorCheck&lt;/item&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180207150540666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="2、colorButtonNormal"><a href="#2、colorButtonNormal" class="headerlink" title="2、colorButtonNormal"></a>2、colorButtonNormal</h4><p>用于控制normal状态下button的颜色（注意和button的background属性的区别，设置colorButtonNormal后button依旧会具有涟漪效果，而设置background就没有涟漪效果了）</p>
<p>设置colorButtonNormal后button的normal状态如下<br><img src="http://img.blog.csdn.net/20180207150732903?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="3、android-navigationBarColor"><a href="#3、android-navigationBarColor" class="headerlink" title="3、android:navigationBarColor"></a>3、android:navigationBarColor</h4><p>控制底部导航栏的背景色（注意前边必须有android:），例如：<br><img src="http://img.blog.csdn.net/20180207150811555?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="常用控件颜色属性"><a href="#常用控件颜色属性" class="headerlink" title="常用控件颜色属性"></a>常用控件颜色属性</h3><h4 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h4><ul>
<li>unfocused —— colorControlNormal</li>
<li>focus —— colorAccent</li>
<li>cursor —— colorAccent</li>
<li>text color —— android:textColorPrimary</li>
</ul>
<h4 id="RadioButton"><a href="#RadioButton" class="headerlink" title="RadioButton"></a>RadioButton</h4><ul>
<li>unselected —— colorControlNormal</li>
<li>selected —— colorAccent</li>
</ul>
<h4 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h4><ul>
<li>box unchecked —— colorControlNormal</li>
<li>box checked —— colorAccent</li>
</ul>
<h4 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h4><ul>
<li>background —— 布局文件中设置android:background=”?attr/colorPrimary</li>
<li>overflow icon —— android:textColorPrimary</li>
<li>navigation icon —— android:textColorPrimary</li>
<li>action icons —— android:textColorPrimary</li>
<li>overflow menu background —— android:colorBackground</li>
<li>overflow text color —— android:textColorPrimary</li>
</ul>
<h4 id="ActionBar"><a href="#ActionBar" class="headerlink" title="ActionBar"></a>ActionBar</h4><ul>
<li>background —— colorPrimary</li>
<li>title color —— android:textColorPrimary</li>
<li>overflow icon —— android:textColorPrimary</li>
<li>up button —— android:textColorPrimary</li>
<li>action icons —— android:textColorPrimary</li>
<li>overflow menu background —— android:colorBackground</li>
<li>overflow text color —— android:textColorPrimary</li>
</ul>
<h4 id="Spinner"><a href="#Spinner" class="headerlink" title="Spinner"></a>Spinner</h4><ul>
<li>indicator (not pressed) —— colorControlNormal</li>
<li>indicator (pressed) —— colorAccent</li>
<li>selected entry text color —— “android:textColorPrimary</li>
</ul>
<h4 id="SwitchCompat"><a href="#SwitchCompat" class="headerlink" title="SwitchCompat"></a>SwitchCompat</h4><ul>
<li>thumb switch off —— colorSwitchThumbNormal</li>
<li>thumb switch on —— colorAccent</li>
<li>track overlay —— colorAccent”</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/31/我的图片四级缓存框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/我的图片四级缓存框架/" itemprop="url">我的图片四级缓存框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-31T00:00:00+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开发App一定涉及到图片加载、图片处理，那就必须会用到三方的图片框架，要么选择自己封装。至于主流的三方图片框架，就不得不说老牌的ImageLoader、如今更流行的Glide、Picasso和Fresco。但三方的框架本文不会过多介绍。</p>
<p>Glide等框架，毕竟是大神及团队花费很大精力开发和维护的开源框架，他们的设计思路、性能优化、代码规范等等很值得我们学习，之前一段时间也研究过Glide的源码（不得不由衷佩服）。</p>
<p>今天，将自己对于图片加载的思路想法，也借鉴了开源框架的一些好的点，封装了一个图片加载框架——JsLoader。（github地址：<a href="https://github.com/shuaijia/JsImageLoader" target="_blank" rel="noopener">https://github.com/shuaijia/JsImageLoader</a>）与大家分享。</p>
<p>文章目录：<br><img src="http://img.blog.csdn.net/20180128213327798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>至于图片的网络请求，我这里还是使用Android原生提供的HttpUrlConnection；请求网络图片时，开启子线程进行操作，使用线程池对线程进行统一管理；线程间通信还是用了Handler；提到图片加载，大家肯定会立刻想到图片的三级缓存（内存—外存—网络），但我这里提供一个新的思路——<strong>四级缓存，与三级缓存不同的是内存又分为了两级</strong>，这些稍后会详细介绍到。</p>
<p>本文目的在于和大家分享一个图片框架的封装思路，至于代码的优化，如使用OkHttp替换HttpUrlConnection，使用RxJava替换Handler等，或者有别的不足的地方，也希望大家能够反馈给我，我们一起进步。</p>
<p>先看下整体流程图：</p>
<p><img src="http://img.blog.csdn.net/20180128213304914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadFactory &#123;</span><br><span class="line"></span><br><span class="line">    //Android的线程池类</span><br><span class="line">    private static ThreadPoolExecutor threadPoolExecutor=null;</span><br><span class="line">    //获取当前用户的手机的CPU的核心数</span><br><span class="line">    private static int num= Runtime.getRuntime().availableProcessors();</span><br><span class="line">    //用于存储提交任务的任务队列</span><br><span class="line">    private static BlockingDeque&lt;Runnable&gt; workQueue=new LinkedBlockingDeque&lt;&gt;(num*50);</span><br><span class="line">    private MyThreadFactory()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static ThreadPoolExecutor getThreadPoolExecutor()&#123;</span><br><span class="line">        if(null==threadPoolExecutor)&#123;</span><br><span class="line">            threadPoolExecutor=new ThreadPoolExecutor(num*2, num*4, 8, TimeUnit.SECONDS, workQueue, new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">//            threadPoolExecutor=new ThreadPoolExecutor(1, 1, 8, TimeUnit.SECONDS, workQueue, new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        &#125;</span><br><span class="line">        return threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前类是一个线程池的管理类。由于当前的线程池，在整个项目中不需要创建多个对象，直接使用单例模式进行创建。</p>
<blockquote>
<p> <strong>补充</strong>：Android中的线程池<br> 在Android中使用线程池的类是：ThreadPoolExecutor；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(int corePoolSize, int maxinumPoolSize, long keepAliveTime, TimeUnit unit, BlockingDeque&lt;Runnable&gt; workQueue, ThreadFactory threadFactory);</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>int corePoolSize      : 线程池中的核心线程数</li>
<li>int maxinumPoolSize   ：线程池中允许的最大线程数目</li>
<li>long keepAliveTime    ：非核心线程的超时时间，超出这个时间非核心线程会被回收</li>
<li>TimeUnit unit         ：非核心线程的超时时间的时间单位</li>
<li>BlockingDeque<runnable> workQueue  ： 保存需要线程池执行的任务的列表</runnable></li>
<li>ThreadFactory threadFactory        ： 线程工厂，只是一个接口，只有一个方法Thread newThread(Runnable r)</li>
</ul>
<p>在上文展示的类中，我们获取了手机的CPU核心数num，本线程池的核心线程数为CPU数的2倍，最大线程数为CPU核心数的4倍。</p>
<h3 id="内存一级缓存"><a href="#内存一级缓存" class="headerlink" title="内存一级缓存"></a>内存一级缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static final HashMap&lt;String,Bitmap&gt; mHardBitmapCache=new LinkedHashMap&lt;String,Bitmap&gt;(</span><br><span class="line">            M_LINK_SIZE/2,0.75f,true)&#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 这个方法是是put或putAll时调用,默认返回false,表示添加数据时不移除最旧的数据.</span><br><span class="line">	 * @param eldest</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected boolean removeEldestEntry(Entry&lt;String, Bitmap&gt; eldest) &#123;</span><br><span class="line">		if (size() &gt; M_LINK_SIZE) &#123;</span><br><span class="line">			// 当map的size大于30时，把最近不常用的key放到mSoftBitmapCache中，从而保证mHardBitmapCache的效率</span><br><span class="line">			Bitmap value = eldest.getValue();</span><br><span class="line">			if (value != null) &#123;</span><br><span class="line">				mWeakBitmapCache.put(eldest.getKey(),new SoftReference&lt;Bitmap&gt;(value));</span><br><span class="line">			&#125;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义的内存中的一级缓存，即保存作为强引用的位置的HashMap。</p>
<p>此处HashMap使用的是<strong>LinkedHashMap</strong>。LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，<strong>先得到的记录肯定是先插入的</strong>。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p>
<p>正是由于LinkedHashMap具有<strong>记忆</strong>功能，最近插入的最新访问，就符合了我们的最近最多使用的原则。但由于其遍历速度慢，我们对其容量进行设定，最多30和元素。</p>
<p>重写removeEldestEntry方法，当map的size大于30时，把最近不常用的key放到mSoftBitmapCache中（也就是内存第二级缓存），从而保证mHardBitmapCache的效率。</p>
<p>这里我们在Map中是以Url和Bitmap为Key-Value存储的，由于LinkedHashMap存放少，而且插入移出快，所以这里用的是Bitmap的强引用。</p>
<p>如果LinkedHashMap中包含我们需要的图片，则将图片直接返回。但是注意：此时我们认为此图使用频率更高，因此我们需要先将该元素移出，在加入（这是由于该map后插入的遍历时先读取）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mHardBitmapCache.remove(netUrlKey);</span><br><span class="line">mHardBitmapCache.put(netUrlKey,usefulBitmap);</span><br></pre></td></tr></table></figure>
<p>此为内存的一级缓存。</p>
<h3 id="内存二级缓存"><a href="#内存二级缓存" class="headerlink" title="内存二级缓存"></a>内存二级缓存</h3><p>如果内存的LinkedHashMap中未获取到我们想要的图片的话，在二级缓存中进行查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; mWeakBitmapCache = new ConcurrentHashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;(</span><br><span class="line">            M_LINK_SIZE / 2);</span><br></pre></td></tr></table></figure>
<p>这时就用到了ConcurrentHashMap，它的最大特点就是<strong>线程安全</strong>、高并发、存储量大。由于存储量大，所以我们存放Bitmap时就需要使用其软引用了。</p>
<p>如果此map中含有需要的图片，则先取出其软引用，在从软引用中获取Bitmap对象返回。再将其移至一级缓存中。</p>
<p>内存的读取整体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里定义的操作方法完成的是从内存中的Map中获取图片的对象</span><br><span class="line"> * 既然已经在内存中了，默认已经完成了压缩</span><br><span class="line"> *</span><br><span class="line"> * @param netUrlKey  作为图片在Map中唯一标志的网络图片URL</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Bitmap getBitmapFromRAM(String netUrlKey)&#123;</span><br><span class="line"></span><br><span class="line">    if(mHardBitmapCache.containsKey(netUrlKey))&#123;</span><br><span class="line"></span><br><span class="line">        Bitmap usefulBitmap=mHardBitmapCache.get(netUrlKey);</span><br><span class="line">        if(null!=usefulBitmap)&#123;</span><br><span class="line">            //如果存在正在内存中的Bitmap图片，将图片的使用级别向前提，并返回Bitmap对象</span><br><span class="line">            mHardBitmapCache.remove(netUrlKey);</span><br><span class="line">            mHardBitmapCache.put(netUrlKey,usefulBitmap);</span><br><span class="line">            return usefulBitmap;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //这里的情况是虽然在集合中包含对应的Key但是通过key得不到对应的Bitmap，此时将</span><br><span class="line">            //key从Map中清楚，并返回null</span><br><span class="line">            mHardBitmapCache.remove(netUrlKey);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //如果在强引用中不包含对应的key，那么在软引用中进行查找</span><br><span class="line">        if(mWeakBitmapCache.containsKey(netUrlKey))&#123;</span><br><span class="line">            SoftReference&lt;Bitmap&gt; usefulSoftBitmap=mWeakBitmapCache.get(netUrlKey);</span><br><span class="line">            if(null!=usefulSoftBitmap)&#123;</span><br><span class="line">                //从软应用中获取出对应的Bitmap对象</span><br><span class="line">                Bitmap usefulBitmap = usefulSoftBitmap.get();</span><br><span class="line">                if(null!=usefulBitmap)&#123;</span><br><span class="line">                    //将软引用中的低级别图片转移到强引用中</span><br><span class="line">                    mHardBitmapCache.put(netUrlKey,usefulBitmap);</span><br><span class="line">                    return usefulBitmap;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //软引用中包含key但是获取不到图片</span><br><span class="line">                    mWeakBitmapCache.remove(netUrlKey);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //软引用中包含key但是获取不到图片</span><br><span class="line">                mWeakBitmapCache.remove(netUrlKey);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //软引用中也不包括这个key，那么从判断SD卡中是否存在这个资源图片</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别声明：在存放入内存前，会将图片进行压缩。</p>
<h3 id="SD卡缓存"><a href="#SD卡缓存" class="headerlink" title="SD卡缓存"></a>SD卡缓存</h3><p>内存中没有图片的话，就去文件中查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取已经保存的数据的位置的路径</span><br><span class="line"> *</span><br><span class="line"> * @param netUrlorPath</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static String getSavedPath(String netUrlorPath) &#123;</span><br><span class="line"></span><br><span class="line">	String savedPath = null;</span><br><span class="line">	if (StorageUtil.isPhoneHaveSD()) &#123;</span><br><span class="line">		// 创建以SD卡根目录为路径的File对象</span><br><span class="line">		File fileBySD = new File(StorageUtil.getPathBySD());</span><br><span class="line">		// 创建SD卡根目录下以当前应用包名为文件夹的文件对象，并验证是否存在当前目录</span><br><span class="line">		File fileBySDSon = new File(fileBySD, PackageUtil.getAppPackageName());</span><br><span class="line">		// File fileBySDSon=new File(fileBySD,&quot;AA&quot;);</span><br><span class="line">		if (fileBySDSon.exists()) &#123;</span><br><span class="line">			String md5Url = EncryptUtil.md5(netUrlorPath);</span><br><span class="line">			// 以包名为文件夹的对象存在的时候，通过将文件对象和图片的名称的拼接构建文件对象</span><br><span class="line">			File imageFile = new File(fileBySDSon, URLEncoder.encode(md5Url));</span><br><span class="line">			if (imageFile.exists()) &#123;</span><br><span class="line">				// 图片文件对象存在的时候获取当前的图片对象对应的路径</span><br><span class="line">				savedPath = imageFile.getAbsolutePath();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 创建以Cache根目录为路径的File对象</span><br><span class="line">		File fileByCache = new File(StorageUtil.getPathBycache());</span><br><span class="line">		// 创建SD卡根目录下以当前应用包名为文件夹的文件对象，并验证是否存在当前目录</span><br><span class="line">		File fileByCacheSon = new File(fileByCache, PackageUtil.getAppPackageName());</span><br><span class="line">		// File fileByCacheSon=new File(fileByCache,&quot;AA&quot;);</span><br><span class="line">		if (fileByCacheSon.exists()) &#123;</span><br><span class="line">			String md5Url = EncryptUtil.md5(netUrlorPath);</span><br><span class="line">			// 以包名为文件夹的对象存在的时候，通过将文件对象和图片的名称的拼接构建文件对象</span><br><span class="line">			File imageFile = new File(fileByCacheSon, URLEncoder.encode(md5Url));</span><br><span class="line">			if (imageFile.exists()) &#123;</span><br><span class="line">				// 图片文件对象存在的时候获取当前的图片对象对应的路径</span><br><span class="line">				savedPath = imageFile.getAbsolutePath();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return savedPath;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上方代码是根据图片url获取到图片在文件中的路径。</p>
<p>所以的缓存图片，会保存在本包名文件夹下，以url的md5值为名字的文件中，判断到有此文件的话，将文件路径返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里完成的操作是判断传递进来的路径是否包括Bitmap对象，如果存在将Bitmap对象返回 否则返回null</span><br><span class="line"> *</span><br><span class="line"> * @param saveTime</span><br><span class="line"> *            图片的保存时间</span><br><span class="line"> * @param netUrl</span><br><span class="line"> *            网络图片的网络路径作为文件名称</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Bitmap getBitmapFromSD(long saveTime, String netUrl) &#123;</span><br><span class="line"></span><br><span class="line">	long nativeSaveTime = saveTime &gt; 0 ? saveTime : DATA_DEFAULT_SAVETIME;</span><br><span class="line">	long actualSaveTime = 0L;</span><br><span class="line">	if (null == netUrl) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	String imageSavePath = getSavedPath(netUrl);</span><br><span class="line">//	System.out.println(&quot;已经存储的图片的路径：：&quot; + imageSavePath);</span><br><span class="line">	if (null == imageSavePath) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	File imageFile = new File(imageSavePath);</span><br><span class="line">	if (!imageFile.exists()) &#123;</span><br><span class="line">		// throw new StructException(&quot;需要的文件不存在！&quot;);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	actualSaveTime = System.currentTimeMillis() - imageFile.lastModified();</span><br><span class="line">	if (actualSaveTime &gt; nativeSaveTime) &#123;</span><br><span class="line">		imageFile.delete();</span><br><span class="line">		//System.out.println(&quot;文件超时了！&quot;);</span><br><span class="line">		return null;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 这里的逻辑是当文件对象存在的时候将该文件对象获取出来，并生成Bitmap对象并返回</span><br><span class="line">	 */</span><br><span class="line">	// Bitmap sdBitmap= BitmapFactory.decodeFile(imageSavePath);</span><br><span class="line">	// 从SD卡中获取图片的时候直接进行图片的压缩处理防止OOM</span><br><span class="line"></span><br><span class="line">	//System.out.println(&quot;保存的图片的链接：&quot; + imageSavePath);</span><br><span class="line">	Bitmap sdBitmap = ImageUtil.getCompressBitmapBYScreen(imageSavePath);</span><br><span class="line">	return sdBitmap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断到文件中有我们需要的图片，会拿到文件路径。但是，我们有设定文件有效时间，超过该时间则视为超时，返回null，否则读取该文件。根据图片的路径和当前手机的默认屏幕分辨率进行图片压缩再返回。</p>
<p>文件中有该图片，那就将该图片移植内存中，以提高优先级，而且内存两级中都放入该图片。</p>
<h3 id="网络获取"><a href="#网络获取" class="headerlink" title="网络获取"></a>网络获取</h3><p>以上都没拿到图片的话，那只能从网络来获取啦！</p>
<p>对http还是https进行判断，分别对应使用HttpUrlConnection和HttpsUrlConnection。他们代码类似，就只贴其中一个了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    public static InputStream getHttpIOByGet(String netUrl) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">//        System.out.println(&quot;网络的链接：&quot;+netUrl);</span><br><span class="line"></span><br><span class="line">        URL url = new URL(netUrl);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">        conn.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">        conn.setConnectTimeout(5000);</span><br><span class="line">        int code = conn.getResponseCode();</span><br><span class="line">//        System.out.println(&quot;返回码：：&quot;+code);</span><br><span class="line">        if (code == 200) &#123;</span><br><span class="line">            InputStream is = conn.getInputStream();</span><br><span class="line">            return is;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>返回码200，表示请求成功，就将输入流返回，否则返回null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap= BitmapFactory.decodeStream(inputStream);</span><br></pre></td></tr></table></figure>
<p>获取输入流后，使用上方代码获取Bitmap对象，原因大家懂的。</p>
<p>获取到图片后，再依次存入sd卡和内存中，因为是好是操作，就在子线程中进行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		//3.1、从网络获取图片</span><br><span class="line">		//3.2、将图片压缩后的保存到SD卡或机身内存中</span><br><span class="line">		FileUtil.putBitmapToSD(netUrl, finalThreeCacheBitmap);</span><br><span class="line">		//3.4、将图片保存到Map中</span><br><span class="line">		CacheRAM.putBitmapToRAM(netUrl, finalThreeCacheBitmap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>
<h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>这里主要想介绍下图片的压缩：因为图片加载很容易造成OOM，所以图片压缩处理显得尤为重要。</p>
<p>提供集中压缩方式：</p>
<ul>
<li>根据期望大小压缩</li>
<li>根据期望尺寸压缩</li>
<li>根据当前手机的默认屏幕分辨率进行图片的压缩</li>
</ul>
<p>这里就不再贴代码了，可以去我的github中查看。<a href="https://github.com/shuaijia/JsImageLoader/blob/master/jsimageloader/src/main/java/com/jia/jsloader/utils/ImageUtil.java" target="_blank" rel="noopener">https://github.com/shuaijia/JsImageLoader/blob/master/jsimageloader/src/main/java/com/jia/jsloader/utils/ImageUtil.java</a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="1、添依赖"><a href="#1、添依赖" class="headerlink" title="1、添依赖"></a>1、添依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    ...</span><br><span class="line">    maven &#123; url &apos;https://www.jitpack.io&apos; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;com.github.shuaijia:JsImageLoader:v1.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、添权限"><a href="#2、添权限" class="headerlink" title="2、添权限"></a>2、添权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3、继承JsApplication"><a href="#3、继承JsApplication" class="headerlink" title="3、继承JsApplication"></a>3、继承JsApplication</h4><h4 id="4、请求"><a href="#4、请求" class="headerlink" title="4、请求"></a>4、请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JsLoader.with(this)</span><br><span class="line">    .load(&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=699359866,1092793192&amp;fm=27&amp;gp=0.jpg&quot;)</span><br><span class="line">    .defaultImg(R.mipmap.default)</span><br><span class="line">    .errorImg(R.mipmap.error)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<p>由于本人水平有限，不免有不对或不足的地方，希望大家能够提出，我们共同进步。</p>
<p>更多精彩内容，请关注我的微信公众号——<strong>Android机动车</strong></p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/22/MVP模式的经典封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/MVP模式的经典封装/" itemprop="url">MVP模式的经典封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-22T00:00:00+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>人之所以能，是相信能。</p>
</blockquote>
<p>说到MVP，大家应该都不陌生了，由于其高度解等等优点，越来越多的项目使用这个设计模式。然而，优点虽在，缺点也不少，其中一个就是类多了很多，而且V与P直接要项目通信，那么P就得持有V得实例，但如果活动挂掉了，如果没有对V进行释放，还有导致内存溢出得问题，而且，那么多的接口函数，看得到人眼花缭乱，也使得很多人在使用这个模式的时候望而尚步。</p>
<p>回归正题，最近在进行代码重构，决定采用MVP模式进行开发。如果我们不进行封装，单纯地简单使用MVP来开发，这要就会出现如上的问题，<strong>接口和类多而且重复</strong>。和别人协同开发也存在问题。那么对MVP模式进行封装就显得很重要了。当然，一千个人中有一千个哈姆雷特，这里提供一下我的思路，供大家参考。 </p>
<h2 id="什么是MVP模式"><a href="#什么是MVP模式" class="headerlink" title="什么是MVP模式"></a>什么是MVP模式</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610c365f661ca89?w=954&amp;h=536&amp;f=png&amp;s=34459" alt=""></p>
<p>MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。</p>
<p>使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要。</p>
<p>其实，简而言之：view就是UI，model就是数据处理，而persenter则是他们的纽带。</p>
<h4 id="使用MVP的结构"><a href="#使用MVP的结构" class="headerlink" title="使用MVP的结构"></a>使用MVP的结构</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610c42092395a18?w=550&amp;h=182&amp;f=png&amp;s=26771" alt=""></p>
<h4 id="再对比下MVC"><a href="#再对比下MVC" class="headerlink" title="再对比下MVC"></a>再对比下MVC</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610c41e53d7b631?w=513&amp;h=285&amp;f=png&amp;s=3912" alt=""></p>
<p>MVP模式还是存在一些不足之处的，最大的不足就是类的快速增多，但相对于MVC的臃肿、MVP的高度解耦来说，类的增多可能就洒洒水啦~~~</p>
<h2 id="封装思路"><a href="#封装思路" class="headerlink" title="封装思路"></a>封装思路</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610c438af2123ce?w=1403&amp;h=787&amp;f=png&amp;s=41240" alt=""></p>
<p>上图介绍：</p>
<p><strong>Contract</strong>：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。</p>
<p><strong>ViewInterface</strong>： view层接口，定义了view中的UI操作</p>
<p><strong>ModelInterface</strong>： model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等</p>
<p><strong>CallbackInterface</strong>： model层操作数据完成后的回调</p>
<p><strong>BasePersenter</strong>： Persenter父类，主要是对相关view的获取，销毁等操作</p>
<p><strong>View</strong>： view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应</p>
<p><strong>Model</strong>： model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack</p>
<p><strong>Persenter</strong>： persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示</p>
<h2 id="框架封装"><a href="#框架封装" class="headerlink" title="框架封装"></a>框架封装</h2><h3 id="1、Presenter的封装"><a href="#1、Presenter的封装" class="headerlink" title="1、Presenter的封装"></a>1、Presenter的封装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: Presenter的根父类</span><br><span class="line"> * Created by jia on 2016/10/27.</span><br><span class="line"> * 人之所以能，是相信能</span><br><span class="line"> */</span><br><span class="line">public abstract class BasePresenter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //View接口类型的软引用</span><br><span class="line">    protected Reference&lt;T&gt; mViewRef;</span><br><span class="line"></span><br><span class="line">    public void attachView(T view) &#123;</span><br><span class="line">        //建立关系</span><br><span class="line">        mViewRef = new SoftReference&lt;T&gt;(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected T getView() &#123;</span><br><span class="line">        return mViewRef.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isViewAttached() &#123;</span><br><span class="line">        return mViewRef != null &amp;&amp; mViewRef.get() != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void detachView() &#123;</span><br><span class="line">        if (mViewRef != null) &#123;</span><br><span class="line">            mViewRef.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来观察下这个base类：</p>
<p>先设置一泛型T，T为与presenter相关的view。BasePresenter中持有一个view的软引用。</p>
<p>在关联方法中将view对象传入，并存入软引用中，创建获取、取消关联和判断方法。</p>
<p>至于使用软引用，是为了防止所持的view都销毁了，但presenter一直持有，导致内存泄漏。</p>
<h3 id="2、view的封装"><a href="#2、view的封装" class="headerlink" title="2、view的封装"></a>2、view的封装</h3><p>view的封装，主要是BaseActivity和BaseFragment的封装。</p>
<h3 id="2-1、BaseActivity"><a href="#2-1、BaseActivity" class="headerlink" title="2.1、BaseActivity"></a>2.1、BaseActivity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseActivity&lt;V, T extends BasePresenter&lt;V&gt;&gt; extends FragmentActivity &#123;</span><br><span class="line"></span><br><span class="line">    public String TAG = getClass().getSimpleName() + &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    protected T mPresenter;</span><br><span class="line"></span><br><span class="line">    public Context mContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        initActivityView(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mContext = BaseActivity.this;</span><br><span class="line"></span><br><span class="line">        //创建presenter</span><br><span class="line">        mPresenter = createPresenter();</span><br><span class="line"></span><br><span class="line">        findViewById();</span><br><span class="line"></span><br><span class="line">        getData();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        if (null != mPresenter) &#123;</span><br><span class="line">            mPresenter.attachView((V) this);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关于Activity的界面填充的抽象方法，需要子类必须实现</span><br><span class="line">     */</span><br><span class="line">    protected abstract void initActivityView(Bundle savedInstanceState);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载页面元素</span><br><span class="line">     */</span><br><span class="line">    protected abstract void findViewById();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建Presenter 对象</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected abstract T createPresenter();</span><br><span class="line"></span><br><span class="line">    protected abstract void getData();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        ...</span><br><span class="line">        if (null != mPresenter) &#123;</span><br><span class="line">            mPresenter.detachView();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseActivity设置两个泛型——V和P，明显地，分别代表对应的View和Presenter。</p>
<p>其持有一个BasePresenter，在onCreated方法中，使用createPresenter方法返回对应的BasePresenter的子类，我们就可以使用了。</p>
<p>这里注意一下view和presenter的处理：在onCreated中创建Presenter对象，但其内部的view软引用还是空；在onResume中关联view，此时presenter已经持有view的软引用；当然，还需要在onDestroy中取消关联。</p>
<p>至于其他的封装就不再介绍了，相信大家肯定还有更优的封装方法。</p>
<h3 id="2-2-BaseFragment"><a href="#2-2-BaseFragment" class="headerlink" title="2.2 BaseFragment"></a>2.2 BaseFragment</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseFragment&lt;V, T extends BasePresenter&lt;V&gt;&gt; extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    public String TAG = getClass().getSimpleName() + &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    private static final String STATE_SAVE_IS_HIDDEN = &quot;STATE_SAVE_IS_HIDDEN&quot;;</span><br><span class="line">    protected T mPresenter;</span><br><span class="line"></span><br><span class="line">    //定义一个View用来保存Fragment创建的时候使用打气筒工具进行的布局获取对象的存储</span><br><span class="line">    protected View view;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当Fragment进行创建的时候执行的方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mPresenter = createPresenter();//创建presenter</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">        outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法是关于Fragment完成创建的过程中，进行界面填充的方法,该方法返回的是一个view对象</span><br><span class="line">     * 在这个对象中封装的就是Fragment对应的布局</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        view = initFragmentView(inflater);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法当onCreateView方法中的view创建完成之后，执行</span><br><span class="line">     * 在inflate完成view的创建之后，可以将对应view中的各个控件进行查找findViewById</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(View view, Bundle savedInstanceState) &#123;</span><br><span class="line">        initFragmentChildView(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法是在Fragment完成创建操作之后，进行数据填充操作的时候执行的方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityCreated(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState);</span><br><span class="line">        initFragmentData(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 完成打气筒操作</span><br><span class="line">     */</span><br><span class="line">    protected abstract View initFragmentView(LayoutInflater inflater);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行findViewById的操作</span><br><span class="line">     *</span><br><span class="line">     * @param view 打气筒生成的View对象</span><br><span class="line">     */</span><br><span class="line">    protected abstract void initFragmentChildView(View view);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 网络数据填充的操作</span><br><span class="line">     *</span><br><span class="line">     * @param savedInstanceState</span><br><span class="line">     */</span><br><span class="line">    protected abstract void initFragmentData(Bundle savedInstanceState);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建Presenter对象</span><br><span class="line">     */</span><br><span class="line">    protected abstract T createPresenter();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        if (null != mPresenter) &#123;</span><br><span class="line">            mPresenter.attachView((V) this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        if (null != mPresenter) &#123;</span><br><span class="line">            mPresenter.detachView();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseFragment与BaseA类似就不再累赘。</p>
<h3 id="3、Contract契约类"><a href="#3、Contract契约类" class="headerlink" title="3、Contract契约类"></a>3、Contract契约类</h3><p>契约，顾名思义，规范定义，定义功能和模板。</p>
<p>在契约类中定义View的接口，Model的接口。因为Model将数据返给Presenter是使用回调方式，所以还需要再契约类中定义对应的回调。</p>
<p>具体看示例吧。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>这里我们以登录功能模块为例：</p>
<h3 id="1、契约类"><a href="#1、契约类" class="headerlink" title="1、契约类"></a>1、契约类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> * Created by jia on 2017/12/20.</span><br><span class="line"> * 人之所以能，是相信能</span><br><span class="line"> */</span><br><span class="line">public class LoginContract &#123;</span><br><span class="line"></span><br><span class="line">    public interface LoginView&#123;</span><br><span class="line"></span><br><span class="line">        void onCheckFormatSuccess();</span><br><span class="line"></span><br><span class="line">        void onCheckFormatFail(String info);</span><br><span class="line"></span><br><span class="line">        void onLoginSuccess(Login login);</span><br><span class="line"></span><br><span class="line">        void onLoginFail(String errorInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface LoginModel&#123;</span><br><span class="line">        void login(String name,String password,LoginCallBack callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface LoginCallBack&#123;</span><br><span class="line">        void onSuccess(Login login);</span><br><span class="line"></span><br><span class="line">        void onFail(String errorInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了登录页面的view接口、model接口和对应的回调。</p>
<p>在view中，只定义与UI展示的相关方法，如检查账号密码格式成功（失败）、登录成功（失败）等。</p>
<p>model负责数据请求，所以在接口中只定义了登录的方法。</p>
<p>回调定义了登录成功还是失败的方法。</p>
<h3 id="2、Model实现类"><a href="#2、Model实现类" class="headerlink" title="2、Model实现类"></a>2、Model实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 登录 Model实现类</span><br><span class="line"> * Created by jia on 2017/12/20.</span><br><span class="line"> * 人之所以能，是相信能</span><br><span class="line"> */</span><br><span class="line">public class LoginModelImpl implements LoginContract.LoginModel &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录方法</span><br><span class="line">     * @param name</span><br><span class="line">     * @param password</span><br><span class="line">     * @param callBack</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void login(String name, String password, final LoginContract.LoginCallBack callBack) &#123;</span><br><span class="line">        LoginNetUtils.getInstance().login(name, password, new BaseSubscriber&lt;Login&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(Login login) &#123;</span><br><span class="line">                callBack.onSuccess(login);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(String info) &#123;</span><br><span class="line">                callBack.onFail(info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建Model实现类，重写其登录方法既可，将登录接口交给回调。</p>
<h3 id="3、Presenter"><a href="#3、Presenter" class="headerlink" title="3、Presenter"></a>3、Presenter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 登录主持类</span><br><span class="line"> * Created by jia on 2017/12/20.</span><br><span class="line"> * 人之所以能，是相信能</span><br><span class="line"> */</span><br><span class="line">public class LoginPresenter extends BasePresenter&lt;LoginContract.LoginView&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private LoginModelImpl model;</span><br><span class="line"></span><br><span class="line">    public LoginPresenter() &#123;</span><br><span class="line">        model = new LoginModelImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检查格式</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @param password</span><br><span class="line">     */</span><br><span class="line">    public void checkFormat(String name, String password) &#123;</span><br><span class="line">        if (TextUtils.isEmpty(name)) &#123;</span><br><span class="line">            getView().onCheckFormatFail(&quot;请输入用户名&quot;);</span><br><span class="line">        &#125; else if (TextUtils.isEmpty(password)) &#123;</span><br><span class="line">            getView().onCheckFormatFail(&quot;请输入密码&quot;);</span><br><span class="line">        &#125; else if (password.length() &lt; 6 || password.length() &gt; 18) &#123;</span><br><span class="line">            getView().onCheckFormatFail(&quot;密码格式不正确&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getView().onCheckFormatSuccess();</span><br><span class="line">            login(name, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @param password</span><br><span class="line">     */</span><br><span class="line">    public void login(String name, String password) &#123;</span><br><span class="line">        model.login(name, password, new LoginContract.LoginCallBack() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(Login login) &#123;</span><br><span class="line">                getView().onLoginSuccess(login);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFail(String errorInfo) &#123;</span><br><span class="line">                getView().onLoginFail(errorInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoginPresenter集成BasePresenter，传入LoginView最为泛型T。</p>
<p>内部持有Model实现类对象。</p>
<p>创建两个方法，一个是检查格式，一个是登录。两个方法就是业务的处理。</p>
<p>如登录方法，登录返回后，在回调中得到数据，也可以再进行一些逻辑判断，将结果交给view的对应的方法。</p>
<p>注意这里使用getView()方法就可以，因为在父类中getView方法直接返回的对应的view实例。</p>
<h3 id="4、View"><a href="#4、View" class="headerlink" title="4、View"></a>4、View</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 登录界面</span><br><span class="line"> */</span><br><span class="line">public class LoginActivity extends BaseActivity&lt;LoginContract.LoginView, LoginPresenter&gt;</span><br><span class="line">        implements LoginContract.LoginView, View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initActivityView(Bundle savedInstanceState) &#123;</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void findViewById() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected LoginPresenter createPresenter() &#123;</span><br><span class="line">        return new LoginPresenter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void getData() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCheckFormatSuccess() &#123;</span><br><span class="line">        loading.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCheckFormatFail(String info) &#123;</span><br><span class="line">        RxToast.error(mContext, info).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoginSuccess(Login login) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoginFail(String errorInfo) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的LoginActivity就是登录功能模块的view，其集成BaseActivity，传入view和presenter泛型。</p>
<p>实现LoginView接口，重写接口定义好的UI方法。</p>
<p>在createPresenter方法中创建LoginPresenter对象并返回。这样，就可以使用mPresenter直接操作逻辑了。</p>
<p>再看下整个功能模块的事件流和数据流<br><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610c87f205af2f3?w=765&amp;h=390&amp;f=png&amp;s=17865" alt=""></p>
<p>大致就是这样了，有不足的地方大家多提意见。^_^</p>
<p>更多精彩内容，关注我的微信公众号——Android机动车</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610c86d893de479?w=344&amp;h=344&amp;f=jpeg&amp;s=8753" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/20/java进阶之抽象类、接口和多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/20/java进阶之抽象类、接口和多态/" itemprop="url">java进阶之抽象类、接口和多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-20T00:00:00+08:00">
                2018-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><img src="http://img.blog.csdn.net/20171228135922046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>抽象层次不同</strong> </p>
<ul>
<li><p>抽象类是对类抽象，而接口是对行为的抽象</p>
</li>
<li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部行为进行抽象</p>
</li>
</ul>
<p><strong>跨域不同</strong> </p>
<ul>
<li><p>抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类</p>
</li>
<li><p>抽象类所体现的是一种继承关系，考虑的是子类与父类本质“是不是”同一类的关系</p>
</li>
<li><p>而接口并不要求实现的类与接口是同一本质，它们之间只存在“有没有这个能力”的关系</p>
</li>
</ul>
<p><strong>设计层次不同</strong> </p>
<ul>
<li><p>抽象类是自下而上的设计，在子类中重复出现的工作，抽象到抽象类中</p>
</li>
<li><p>接口是自上而下，定义行为和规范</p>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态指的是编译期只知道是个人，具体是什么样的人需要在运行时能确定，同样的参数有可能会有不同的实现。</p>
<p>通过抽象建立规范，在运行时替换成具体的对象，保证系统的扩展性、灵活性。</p>
<p>实现多态主要有以下三种方式:</p>
<ul>
<li><p>接口实现</p>
</li>
<li><p>继承父类重写方法</p>
</li>
<li><p>同一类中进行方法重载</p>
</li>
</ul>
<p>不论哪种实现方式，调用者持有的都是基类，不同的实现在他看来都是基类，使用时也当基类用。</p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/19/java进阶之自定义注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/19/java进阶之自定义注解/" itemprop="url">java进阶之自定义注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-19T00:00:00+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>注解是Java 1.5引入的，可以提供代码的额外信息，目前正在被广泛应用。除了Java内置注解，我们也可以自定义注解。</p>
<p>以下就是一个自定义注解的简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE) //注解作用于类型（类，接口，注解，枚举）</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) //运行时保留，运行中可以处理</span><br><span class="line">@Inherited // 注解将被用于该类的子类</span><br><span class="line">@Documented // 生成javadoc文件</span><br><span class="line">public @interface JsAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String DEFAULT_VALUE = &quot;JS&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建此value方法，则使用注解时可直接传参，如 @JsAnnotation(&quot;msg&quot;)</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String value() default DEFAULT_VALUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义注解关键点：</strong></p>
<ul>
<li>@interface关键字定义注解</li>
<li>注解可以被其它注解修饰，最重要的就是元注解</li>
<li>注解和接口类似，内部可以定义常量和方法</li>
<li>注解定义的方法有一些限制：方法不能有参数；返回值只能是基本类型、字符串、Class、枚举、注解、及以上类型的数组；可以包含默认值</li>
</ul>
<h3 id="二、元注解介绍"><a href="#二、元注解介绍" class="headerlink" title="二、元注解介绍"></a>二、元注解介绍</h3><p><strong>元注解就是定义注解的注解。</strong></p>
<p>包含@Target、@Retention、@Inherited、@Documented这四种</p>
<h4 id="1、-Target"><a href="#1、-Target" class="headerlink" title="1、@Target"></a>1、@Target</h4><p>描述注解的使用目标。</p>
<p>其源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解方法返回值是ElementType[],ElementType枚举类型，枚举值就是@Target注解的可取值。</p>
<p><strong>方法名value，这样在使用注解时，可以不需要指定方法名。</strong></p>
<p>可取的值有：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ElementType.PACKAGE</td>
<td>注解作用于包</td>
</tr>
<tr>
<td>ElementType.TYPE</td>
<td>注解作用于类型（类，接口，注解，枚举）</td>
</tr>
<tr>
<td>ElementType.ANNOTATION_TYPE</td>
<td>注解作用于注解</td>
</tr>
<tr>
<td>ElementType.CONSTRUCTOR</td>
<td>注解作用于构造方法</td>
</tr>
<tr>
<td>ElementType.METHOD</td>
<td>注解作用于方法</td>
</tr>
<tr>
<td>ElementType.PARAMETER</td>
<td>注解作用于方法参数</td>
</tr>
<tr>
<td>ElementType.FIELD</td>
<td>注解作用于属性</td>
</tr>
<tr>
<td>ElementType.LOCAL_VARIABLE</td>
<td>注解作用于局部变量</td>
</tr>
</tbody>
</table>
<p>注意：默认可以作用于以上任何目标。</p>
<h4 id="2、-Retention"><a href="#2、-Retention" class="headerlink" title="2、@Retention"></a>2、@Retention</h4><p>描述注解的生命周期。</p>
<p>其源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Retention &#123;</span><br><span class="line">    RetentionPolicy value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解方法返回值是枚举类型RetentionPolicy，枚举值就是@Retention注解的可取值。</p>
<p>可取的值有：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>RetentionPolicy.SOURCE</td>
<td>源码中保留，编译期可以处理</td>
</tr>
<tr>
<td>RetentionPolicy.CLASS</td>
<td>Class文件中保留，Class加载时可以处理</td>
</tr>
<tr>
<td>RetentionPolicy.RUNTIME</td>
<td>运行时保留，运行中可以处理</td>
</tr>
</tbody>
</table>
<p>默认RetentionPolicy.CLASS 值。</p>
<h4 id="3、-Documented"><a href="#3、-Documented" class="headerlink" title="3、@Documented"></a>3、@Documented</h4><p>描述注解可以文档化，是一个标记注解。</p>
<p>在生成javadoc的时候，是不包含注释的，但是如果注解被@Documented修饰，则生成的文档就包含该注解。</p>
<p>其源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、-Inherited"><a href="#4、-Inherited" class="headerlink" title="4、@Inherited"></a>4、@Inherited</h4><p>标记注解，使用@Inherited修饰的注解作用于一个类，则该注解将被用于该类的子类。</p>
<p>其源码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、自定义注解示例"><a href="#三、自定义注解示例" class="headerlink" title="三、自定义注解示例"></a>三、自定义注解示例</h3><h4 id="1、定义注解"><a href="#1、定义注解" class="headerlink" title="1、定义注解"></a>1、定义注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE) //注解作用于类型（类，接口，注解，枚举）</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) //运行时保留，运行中可以处理</span><br><span class="line">@Inherited // 注解将被用于该类的子类</span><br><span class="line">@Documented // 生成javadoc文件</span><br><span class="line">public @interface JsAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String DEFAULT_VALUE = &quot;JS&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 颜色枚举</span><br><span class="line">     *</span><br><span class="line">     * @author peida</span><br><span class="line">     */</span><br><span class="line">    enum Color &#123;</span><br><span class="line">        BULE, RED, GREEN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建此value方法，则使用注解时可直接传参，如 @JsAnnotation(&quot;msg&quot;)</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String value() default DEFAULT_VALUE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 此方法返回为枚举类型，使用注解时，如 @JsAnnotation(color=Color.BLUE)</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Color color() default Color.BULE;</span><br><span class="line"></span><br><span class="line">    int num() default -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：定义了三个方法，三个方法都有默认返回值。定义了Color枚举（因为注解的方法可以返回枚举类型）</p>
<p>这里注意：</p>
<ul>
<li>value方法：使用注解时可直接传参，如 @JsAnnotation(“msg”)</li>
<li>普通方法：使用注解时，如 @JsAnnotation(color=Color.BLUE)</li>
</ul>
<h4 id="2、使用注解"><a href="#2、使用注解" class="headerlink" title="2、使用注解"></a>2、使用注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@JsAnnotation(&quot;jia shuai&quot;)</span><br><span class="line">public class AnnotationTest &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@JsAnnotation(num = 100)</span><br><span class="line">public class AnnotationTest &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@JsAnnotation(color = Color.BLUE)</span><br><span class="line">public class AnnotationTest &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、获取注解"><a href="#3、获取注解" class="headerlink" title="3、获取注解"></a>3、获取注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    AnnotationTest test = new AnnotationTest();</span><br><span class="line">    Class tClass = test.getClass();</span><br><span class="line">    JsAnnotation jsAnnotation = (JsAnnotation) tClass.getAnnotation(JsAnnotation.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(jsAnnotation.value());</span><br><span class="line">    System.out.println(jsAnnotation.color());</span><br><span class="line">    System.out.println(jsAnnotation.num());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/16/安卓屏幕完美适配方案——独家秘笈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/安卓屏幕完美适配方案——独家秘笈/" itemprop="url">安卓屏幕完美适配方案——独家秘笈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-16T00:00:00+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><img src="http://img.blog.csdn.net/20170828091611477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="一、为什么要适配"><a href="#一、为什么要适配" class="headerlink" title="一、为什么要适配"></a>一、为什么要适配</h2><h4 id="由于Android系统的开放性，任何用户、开发者、硬件厂商、运营商都可以对Android系统和硬件进行定制，修改成他们想要的样子。"><a href="#由于Android系统的开放性，任何用户、开发者、硬件厂商、运营商都可以对Android系统和硬件进行定制，修改成他们想要的样子。" class="headerlink" title="由于Android系统的开放性，任何用户、开发者、硬件厂商、运营商都可以对Android系统和硬件进行定制，修改成他们想要的样子。"></a>由于Android系统的开放性，任何用户、开发者、硬件厂商、运营商都可以对Android系统和硬件进行定制，修改成他们想要的样子。</h4><h4 id="但是这种“碎片化”到达什么程度呢？"><a href="#但是这种“碎片化”到达什么程度呢？" class="headerlink" title="但是这种“碎片化”到达什么程度呢？"></a>但是这种“碎片化”到达什么程度呢？</h4><p><img src="http://img.blog.csdn.net/20170828091739561?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="以上每一个矩形都代表一种机型，且它们屏幕尺寸、屏幕分辨率大相径庭。随着Android设备的增多，设备碎片化、品牌碎片化、系统碎片化、屏幕碎片化的程度也在不断加深。"><a href="#以上每一个矩形都代表一种机型，且它们屏幕尺寸、屏幕分辨率大相径庭。随着Android设备的增多，设备碎片化、品牌碎片化、系统碎片化、屏幕碎片化的程度也在不断加深。" class="headerlink" title="以上每一个矩形都代表一种机型，且它们屏幕尺寸、屏幕分辨率大相径庭。随着Android设备的增多，设备碎片化、品牌碎片化、系统碎片化、屏幕碎片化的程度也在不断加深。"></a>以上每一个矩形都代表一种机型，且它们屏幕尺寸、屏幕分辨率大相径庭。随着Android设备的增多，设备碎片化、品牌碎片化、系统碎片化、屏幕碎片化的程度也在不断加深。</h4><h4 id="为了让我们的Android应用在各式各样的手机上运行的时候，能够保持界面效果一直，所以，我们需要对各种手机屏幕进行适配！"><a href="#为了让我们的Android应用在各式各样的手机上运行的时候，能够保持界面效果一直，所以，我们需要对各种手机屏幕进行适配！" class="headerlink" title="为了让我们的Android应用在各式各样的手机上运行的时候，能够保持界面效果一直，所以，我们需要对各种手机屏幕进行适配！"></a>为了让我们的Android应用在各式各样的手机上运行的时候，能够保持界面效果一直，所以，我们需要对各种手机屏幕进行适配！</h4><hr>
<h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><h3 id="1、像素（px）："><a href="#1、像素（px）：" class="headerlink" title="1、像素（px）："></a>1、像素（px）：</h3><h4 id="通常所说的像素，就是CCD-CMOS上光电感应元件的数量，一个感光元件经过感光，光电信号转换，A-D转换等步骤以后，在输出的照片上就形成一个点，我们如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”（Pixel）。"><a href="#通常所说的像素，就是CCD-CMOS上光电感应元件的数量，一个感光元件经过感光，光电信号转换，A-D转换等步骤以后，在输出的照片上就形成一个点，我们如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”（Pixel）。" class="headerlink" title="通常所说的像素，就是CCD/CMOS上光电感应元件的数量，一个感光元件经过感光，光电信号转换，A/D转换等步骤以后，在输出的照片上就形成一个点，我们如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”（Pixel）。"></a>通常所说的像素，就是CCD/CMOS上光电感应元件的数量，一个感光元件经过感光，光电信号转换，A/D转换等步骤以后，在输出的照片上就形成一个点，我们如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”（Pixel）。</h4><h4 id="简而言之，像素就是手机屏幕的最小构成单元。"><a href="#简而言之，像素就是手机屏幕的最小构成单元。" class="headerlink" title="简而言之，像素就是手机屏幕的最小构成单元。"></a>简而言之，<strong>像素就是手机屏幕的最小构成单元</strong>。</h4><hr>
<h3 id="2、分辨率："><a href="#2、分辨率：" class="headerlink" title="2、分辨率："></a>2、分辨率：</h3><h4 id="手机在横向、纵向上的像素点数总和，一般描述成-宽-高-，"><a href="#手机在横向、纵向上的像素点数总和，一般描述成-宽-高-，" class="headerlink" title="手机在横向、纵向上的像素点数总和，一般描述成 宽*高 ，"></a>手机在横向、纵向上的像素点数总和，一般描述成 宽*高 ，</h4><h4 id="即横向像素点个数-纵向像素点个数。"><a href="#即横向像素点个数-纵向像素点个数。" class="headerlink" title="即横向像素点个数*纵向像素点个数。"></a>即<strong>横向像素点个数*纵向像素点个数</strong>。</h4><hr>
<h3 id="3、屏幕尺寸（in）："><a href="#3、屏幕尺寸（in）：" class="headerlink" title="3、屏幕尺寸（in）："></a>3、屏幕尺寸（in）：</h3><h4 id="手机对角线的物理尺寸，单位-英寸（inch），一英寸大约2-54cm，常见的尺寸有4-7寸、5寸、5-5寸、6寸"><a href="#手机对角线的物理尺寸，单位-英寸（inch），一英寸大约2-54cm，常见的尺寸有4-7寸、5寸、5-5寸、6寸" class="headerlink" title="手机对角线的物理尺寸，单位 英寸（inch），一英寸大约2.54cm，常见的尺寸有4.7寸、5寸、5.5寸、6寸"></a>手机对角线的<strong>物理尺寸</strong>，单位 英寸（inch），一英寸大约2.54cm，常见的尺寸有4.7寸、5寸、5.5寸、6寸</h4><hr>
<h3 id="4、屏幕像素密度（dpi）："><a href="#4、屏幕像素密度（dpi）：" class="headerlink" title="4、屏幕像素密度（dpi）："></a>4、屏幕像素密度（dpi）：</h3><h4 id="每英寸长度上像素点个数。"><a href="#每英寸长度上像素点个数。" class="headerlink" title="每英寸长度上像素点个数。"></a>每英寸长度上像素点个数。</h4><h4 id="例如每英寸内有160个像素点，则其像素密度为160dpi。"><a href="#例如每英寸内有160个像素点，则其像素密度为160dpi。" class="headerlink" title="例如每英寸内有160个像素点，则其像素密度为160dpi。"></a>例如每英寸内有160个像素点，则其像素密度为160dpi。</h4><h4 id="公式：-像素密度-像素-尺寸-（dpi-px-in）"><a href="#公式：-像素密度-像素-尺寸-（dpi-px-in）" class="headerlink" title="公式：  像素密度=像素/尺寸  （dpi=px/in）"></a>公式：  <strong>像素密度=像素/尺寸  （dpi=px/in）</strong></h4><hr>
<h3 id="5、标准屏幕像素密度（mdpi）："><a href="#5、标准屏幕像素密度（mdpi）：" class="headerlink" title="5、标准屏幕像素密度（mdpi）："></a>5、标准屏幕像素密度（mdpi）：</h3><h4 id="每英寸长度上还有160个像素点，即称为标准屏幕像素密度（mdpi）。"><a href="#每英寸长度上还有160个像素点，即称为标准屏幕像素密度（mdpi）。" class="headerlink" title="每英寸长度上还有160个像素点，即称为标准屏幕像素密度（mdpi）。"></a>每英寸长度上还有160个像素点，即称为标准屏幕像素密度（mdpi）。</h4><hr>
<h3 id="6、像素密度等级："><a href="#6、像素密度等级：" class="headerlink" title="6、像素密度等级："></a>6、像素密度等级：</h3><h4 id="手机真实像素密度与标准屏幕像素密度（160dpi）的比值。官方给出的0-75、1、1-5、2、3、4，即对应120dpi、160dpi、240dpi、320dpi、480dpi、640dpi。"><a href="#手机真实像素密度与标准屏幕像素密度（160dpi）的比值。官方给出的0-75、1、1-5、2、3、4，即对应120dpi、160dpi、240dpi、320dpi、480dpi、640dpi。" class="headerlink" title="手机真实像素密度与标准屏幕像素密度（160dpi）的比值。官方给出的0.75、1、1.5、2、3、4，即对应120dpi、160dpi、240dpi、320dpi、480dpi、640dpi。"></a>手机真实像素密度与标准屏幕像素密度（160dpi）的比值。官方给出的0.75、1、1.5、2、3、4，即对应120dpi、160dpi、240dpi、320dpi、480dpi、640dpi。</h4><hr>
<h3 id="7、密度无关像素（dp）："><a href="#7、密度无关像素（dp）：" class="headerlink" title="7、密度无关像素（dp）："></a>7、密度无关像素（dp）：</h3><h4 id="density-independent-pixel，叫dp或dip，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位。"><a href="#density-independent-pixel，叫dp或dip，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位。" class="headerlink" title="density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位。"></a>density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位。</h4><hr>
<h3 id="8、独立比例像素（sp）："><a href="#8、独立比例像素（sp）：" class="headerlink" title="8、独立比例像素（sp）："></a>8、独立比例像素（sp）：</h3><h4 id="scale-independent-pixel，叫sp或sip，字体大小专用单位，可根据字体大小首选项进行缩放；"><a href="#scale-independent-pixel，叫sp或sip，字体大小专用单位，可根据字体大小首选项进行缩放；" class="headerlink" title="scale-independent pixel，叫sp或sip，字体大小专用单位，可根据字体大小首选项进行缩放；"></a>scale-independent pixel，叫sp或sip，字体大小专用单位，可根据字体大小首选项进行缩放；</h4><h4 id="推荐使用12sp、14sp、18sp、22sp作为字体大小，不推荐使用奇数和小数，容易造成精度丢失，12sp以下字体太小。"><a href="#推荐使用12sp、14sp、18sp、22sp作为字体大小，不推荐使用奇数和小数，容易造成精度丢失，12sp以下字体太小。" class="headerlink" title="推荐使用12sp、14sp、18sp、22sp作为字体大小，不推荐使用奇数和小数，容易造成精度丢失，12sp以下字体太小。"></a><strong>推荐使用12sp、14sp、18sp、22sp作为字体大小，不推荐使用奇数和小数，容易造成精度丢失，12sp以下字体太小</strong>。</h4><hr>
<h3 id="9、尺寸、像素、像素密度关系："><a href="#9、尺寸、像素、像素密度关系：" class="headerlink" title="9、尺寸、像素、像素密度关系："></a>9、尺寸、像素、像素密度关系：</h3><p><img src="http://img.blog.csdn.net/20170828092517503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h3 id="10、px与dp关系："><a href="#10、px与dp关系：" class="headerlink" title="10、px与dp关系："></a>10、px与dp关系：</h3><h4 id="像素-dp像素密度等级，即px-dp-dpi-160"><a href="#像素-dp像素密度等级，即px-dp-dpi-160" class="headerlink" title="像素=dp像素密度等级，即px=dp(dpi/160)"></a><strong>像素=dp<em>像素密度等级，即px=dp</em>(dpi/160</strong>)</h4><hr>
<h2 id="三、对哪些设备适配"><a href="#三、对哪些设备适配" class="headerlink" title="三、对哪些设备适配"></a>三、对哪些设备适配</h2><h4 id="注意进行Android设备的屏幕适配操作，不是单单对屏幕尺寸多样的各种设备进行的适配，在诸多的物理尺寸的背后是屏幕的分辨率，现在市面上占比最多的六种分辨率：480800、320480、480854、540960、7201280、10801920。在日常适配中只要做好对这几个设备的适配，就能很好的适配其他机型。但是在这几种分辨率的背后存在的更为根本的数据是设备的屏幕像素密度。在Google文档中对于屏幕的像素密度进行了几种规定！"><a href="#注意进行Android设备的屏幕适配操作，不是单单对屏幕尺寸多样的各种设备进行的适配，在诸多的物理尺寸的背后是屏幕的分辨率，现在市面上占比最多的六种分辨率：480800、320480、480854、540960、7201280、10801920。在日常适配中只要做好对这几个设备的适配，就能很好的适配其他机型。但是在这几种分辨率的背后存在的更为根本的数据是设备的屏幕像素密度。在Google文档中对于屏幕的像素密度进行了几种规定！" class="headerlink" title="注意进行Android设备的屏幕适配操作，不是单单对屏幕尺寸多样的各种设备进行的适配，在诸多的物理尺寸的背后是屏幕的分辨率，现在市面上占比最多的六种分辨率：480800、320480、480854、540960、7201280、10801920。在日常适配中只要做好对这几个设备的适配，就能很好的适配其他机型。但是在这几种分辨率的背后存在的更为根本的数据是设备的屏幕像素密度。在Google文档中对于屏幕的像素密度进行了几种规定！"></a>注意进行Android设备的屏幕适配操作，不是单单对屏幕尺寸多样的各种设备进行的适配，在诸多的物理尺寸的背后是屏幕的分辨率，现在市面上占比最多的六种分辨率：480<em>800、320</em>480、480<em>854、540</em>960、720<em>1280、1080</em>1920。在日常适配中只要做好对这几个设备的适配，就能很好的适配其他机型。但是在这几种分辨率的背后存在的更为根本的数据是设备的屏幕像素密度。在Google文档中对于屏幕的像素密度进行了几种规定！</h4><h4 id="另外也需注意对安卓平板、安卓电视等大尺寸、超大尺寸设备的适配。"><a href="#另外也需注意对安卓平板、安卓电视等大尺寸、超大尺寸设备的适配。" class="headerlink" title="另外也需注意对安卓平板、安卓电视等大尺寸、超大尺寸设备的适配。"></a>另外也需注意对安卓平板、安卓电视等大尺寸、超大尺寸设备的适配。</h4><p><img src="http://img.blog.csdn.net/20170828092740251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170828092754716?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h2 id="四、如何适配"><a href="#四、如何适配" class="headerlink" title="四、如何适配"></a>四、如何适配</h2><h3 id="1、适配误区"><a href="#1、适配误区" class="headerlink" title="1、适配误区"></a>1、适配误区</h3><h4 id="在进行适配的时候，人们总是关注于：代码、Layout、Dimens、图片、权重，这几种适配方式并不是屏幕适配的全部方案，除此之外还存在多种小细节来实现屏幕适配。"><a href="#在进行适配的时候，人们总是关注于：代码、Layout、Dimens、图片、权重，这几种适配方式并不是屏幕适配的全部方案，除此之外还存在多种小细节来实现屏幕适配。" class="headerlink" title="在进行适配的时候，人们总是关注于：代码、Layout、Dimens、图片、权重，这几种适配方式并不是屏幕适配的全部方案，除此之外还存在多种小细节来实现屏幕适配。"></a>在进行适配的时候，人们总是关注于：代码、Layout、Dimens、图片、权重，这几种适配方式并不是屏幕适配的全部方案，除此之外还存在多种小细节来实现屏幕适配。</h4><h4 id="如何理解使用dp为单位进行适配？："><a href="#如何理解使用dp为单位进行适配？：" class="headerlink" title="如何理解使用dp为单位进行适配？："></a><strong>如何理解使用dp为单位进行适配？</strong>：</h4><p><img src="http://img.blog.csdn.net/20170828092915968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="但是，使用密度无关像素（dp）也不能做到适配所有屏幕！"><a href="#但是，使用密度无关像素（dp）也不能做到适配所有屏幕！" class="headerlink" title="但是，使用密度无关像素（dp）也不能做到适配所有屏幕！"></a><strong>但是，使用密度无关像素（dp）也不能做到适配所有屏幕！</strong></h4><hr>
<h3 id="2、造成误差原因"><a href="#2、造成误差原因" class="headerlink" title="2、造成误差原因"></a>2、造成误差原因</h3><h4 id="在长期的Android发展过程中，由于Android设备的增多，Google制定的屏幕密度标准（mdpi、hdpi、ldpi等），在众多厂家的生产过程中，已经被打破，人们没有生产数完全符合屏幕密度标准的Android设备，对于真实手机的屏幕密度值，是在Google标准的周围浮动变化的，但是不乏存在一些厂商生产的设备偏离Google的屏幕密度标准比较大，这个时候再使用dp作为单位就不能完完全全的完成适配操作！（dp只有在大家标准统一的情况下才有更好的发展）"><a href="#在长期的Android发展过程中，由于Android设备的增多，Google制定的屏幕密度标准（mdpi、hdpi、ldpi等），在众多厂家的生产过程中，已经被打破，人们没有生产数完全符合屏幕密度标准的Android设备，对于真实手机的屏幕密度值，是在Google标准的周围浮动变化的，但是不乏存在一些厂商生产的设备偏离Google的屏幕密度标准比较大，这个时候再使用dp作为单位就不能完完全全的完成适配操作！（dp只有在大家标准统一的情况下才有更好的发展）" class="headerlink" title="在长期的Android发展过程中，由于Android设备的增多，Google制定的屏幕密度标准（mdpi、hdpi、ldpi等），在众多厂家的生产过程中，已经被打破，人们没有生产数完全符合屏幕密度标准的Android设备，对于真实手机的屏幕密度值，是在Google标准的周围浮动变化的，但是不乏存在一些厂商生产的设备偏离Google的屏幕密度标准比较大，这个时候再使用dp作为单位就不能完完全全的完成适配操作！（dp只有在大家标准统一的情况下才有更好的发展）"></a>在长期的Android发展过程中，由于Android设备的增多，Google制定的屏幕密度标准（mdpi、hdpi、ldpi等），在众多厂家的生产过程中，已经被打破，人们没有生产数完全符合屏幕密度标准的Android设备，对于真实手机的屏幕密度值，是在Google标准的周围浮动变化的，但是不乏存在一些厂商生产的设备偏离Google的屏幕密度标准比较大，这个时候再使用dp作为单位就不能完完全全的完成适配操作！（dp只有在大家标准统一的情况下才有更好的发展）</h4><h4 id="在所有计算公式中存在误差：在计算真实像素密度时运用了开方运算和除法运算，导致所得结果存在误差。"><a href="#在所有计算公式中存在误差：在计算真实像素密度时运用了开方运算和除法运算，导致所得结果存在误差。" class="headerlink" title="在所有计算公式中存在误差：在计算真实像素密度时运用了开方运算和除法运算，导致所得结果存在误差。"></a>在所有计算公式中存在误差：在计算真实像素密度时运用了开方运算和除法运算，导致所得结果存在误差。</h4><h4 id="理论计算造成的误差："><a href="#理论计算造成的误差：" class="headerlink" title="理论计算造成的误差："></a>理论计算造成的误差：</h4><h4 id="在计算对角线上像素点个数时，我们使用勾股定理计算得出，但实则存在误差："><a href="#在计算对角线上像素点个数时，我们使用勾股定理计算得出，但实则存在误差：" class="headerlink" title="在计算对角线上像素点个数时，我们使用勾股定理计算得出，但实则存在误差："></a>在计算对角线上像素点个数时，我们使用勾股定理计算得出，但实则存在误差：</h4><ul>
<li>若将像素长度当做1，分辨率指的是横纵向上的1的个数，计算记过表示的是对角线上有多少个1，但理论上对角线上 根号2 的个数才是像素点的个数！</li>
<li>屏幕对角线并不会和像素对角线重合，使计算结果存在误差。<br><img src="http://img.blog.csdn.net/20170828093445737?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
</ul>
<hr>
<h3 id="3、ldpi、mdpi、hdpi、xhdpi、xxhdpi的使用"><a href="#3、ldpi、mdpi、hdpi、xhdpi、xxhdpi的使用" class="headerlink" title="3、ldpi、mdpi、hdpi、xhdpi、xxhdpi的使用"></a>3、ldpi、mdpi、hdpi、xhdpi、xxhdpi的使用</h3><p>  官方截图：<br>  <img src="http://img.blog.csdn.net/20170828094952313?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170828095644741?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h3 id="4、使用wrap-content、match-parent、权重"><a href="#4、使用wrap-content、match-parent、权重" class="headerlink" title="4、使用wrap_content、match_parent、权重"></a>4、使用wrap_content、match_parent、权重</h3><h4 id="要确保布局的灵活性并适应各种尺寸的屏幕，应使用-“wrap-content”-、“match-parent”和权重控制某些视图组件的宽度和高度。"><a href="#要确保布局的灵活性并适应各种尺寸的屏幕，应使用-“wrap-content”-、“match-parent”和权重控制某些视图组件的宽度和高度。" class="headerlink" title="要确保布局的灵活性并适应各种尺寸的屏幕，应使用 “wrap_content” 、“match_parent”和权重控制某些视图组件的宽度和高度。"></a>要确保布局的灵活性并适应各种尺寸的屏幕，应使用 “wrap_content” 、“match_parent”和权重控制某些视图组件的宽度和高度。</h4><h4 id="使用-“wrap-content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而-“match-parent”（在低于-API-级别-8-的级别中称为-“fill-parent”）则会展开组件以匹配其父视图的尺寸。"><a href="#使用-“wrap-content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而-“match-parent”（在低于-API-级别-8-的级别中称为-“fill-parent”）则会展开组件以匹配其父视图的尺寸。" class="headerlink" title="使用 “wrap_content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而 “match_parent”（在低于 API 级别 8 的级别中称为 “fill_parent”）则会展开组件以匹配其父视图的尺寸。"></a>使用 “wrap_content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而 “match_parent”（在低于 API 级别 8 的级别中称为 “fill_parent”）则会展开组件以匹配其父视图的尺寸。</h4><h4 id="如果使用-“wrap-content”-和-“match-parent”-尺寸值而不是硬编码的尺寸，视图就会相应地仅使用自身所需的空间或展开以填满可用空间。此方法可让布局正确适应各种屏幕尺寸和屏幕方向。"><a href="#如果使用-“wrap-content”-和-“match-parent”-尺寸值而不是硬编码的尺寸，视图就会相应地仅使用自身所需的空间或展开以填满可用空间。此方法可让布局正确适应各种屏幕尺寸和屏幕方向。" class="headerlink" title="如果使用 “wrap_content” 和 “match_parent” 尺寸值而不是硬编码的尺寸，视图就会相应地仅使用自身所需的空间或展开以填满可用空间。此方法可让布局正确适应各种屏幕尺寸和屏幕方向。"></a>如果使用 “wrap_content” 和 “match_parent” 尺寸值而不是硬编码的尺寸，视图就会相应地仅使用自身所需的空间或展开以填满可用空间。此方法可让布局正确适应各种屏幕尺寸和屏幕方向。</h4><hr>
<h3 id="5、使用相对布局，不要使用绝对布局"><a href="#5、使用相对布局，不要使用绝对布局" class="headerlink" title="5、使用相对布局，不要使用绝对布局"></a>5、使用相对布局，不要使用绝对布局</h3><h4 id="我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。"><a href="#我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。" class="headerlink" title="我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。"></a>我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。</h4><h4 id="关于布局的使用应该具体情况具体分析，在进行电视机顶盒的开发中就是使用的是绝对布局。"><a href="#关于布局的使用应该具体情况具体分析，在进行电视机顶盒的开发中就是使用的是绝对布局。" class="headerlink" title="关于布局的使用应该具体情况具体分析，在进行电视机顶盒的开发中就是使用的是绝对布局。"></a>关于布局的使用应该具体情况具体分析，在进行电视机顶盒的开发中就是使用的是绝对布局。</h4><hr>
<h3 id="6、使用限定符进行适配操作"><a href="#6、使用限定符进行适配操作" class="headerlink" title="6、使用限定符进行适配操作"></a>6、使用限定符进行适配操作</h3><h4 id="使用尺寸限定符——large"><a href="#使用尺寸限定符——large" class="headerlink" title="使用尺寸限定符——large"></a>使用尺寸限定符——large</h4><h4 id="使用最小宽度限定符——swdp"><a href="#使用最小宽度限定符——swdp" class="headerlink" title="使用最小宽度限定符——swdp"></a>使用最小宽度限定符——sw<n>dp</n></h4><h4 id="使用屏幕方向限定符"><a href="#使用屏幕方向限定符" class="headerlink" title="使用屏幕方向限定符"></a>使用屏幕方向限定符</h4><hr>
<h3 id="7、多套layout适配"><a href="#7、多套layout适配" class="headerlink" title="7、多套layout适配"></a>7、多套layout适配</h3><h4 id="res-values-layouts-xml"><a href="#res-values-layouts-xml" class="headerlink" title="res/values/layouts.xml:"></a>res/values/layouts.xml:</h4><h4 id="res-values-sw600dp-land-layouts-xml"><a href="#res-values-sw600dp-land-layouts-xml" class="headerlink" title="res/values-sw600dp-land/layouts.xml:"></a>res/values-sw600dp-land/layouts.xml:</h4><h4 id="res-values-sw600dp-port-layouts-xml"><a href="#res-values-sw600dp-port-layouts-xml" class="headerlink" title="res/values-sw600dp-port/layouts.xml:"></a>res/values-sw600dp-port/layouts.xml:</h4><h4 id="res-values-large-land-layouts-xml"><a href="#res-values-large-land-layouts-xml" class="headerlink" title="res/values-large-land/layouts.xml:"></a>res/values-large-land/layouts.xml:</h4><h4 id="res-values-large-port-layouts-xml"><a href="#res-values-large-port-layouts-xml" class="headerlink" title="res/values-large-port/layouts.xml:"></a>res/values-large-port/layouts.xml:</h4><hr>
<h3 id="8、使用自动拉伸位图"><a href="#8、使用自动拉伸位图" class="headerlink" title="8、使用自动拉伸位图"></a>8、使用自动拉伸位图</h3><h4 id="支持各种屏幕尺寸通常意味着您的图片资源还必须能适应各种尺寸。例如，无论要应用到什么形状的按钮上，按钮背景都必须能适应。"><a href="#支持各种屏幕尺寸通常意味着您的图片资源还必须能适应各种尺寸。例如，无论要应用到什么形状的按钮上，按钮背景都必须能适应。" class="headerlink" title="支持各种屏幕尺寸通常意味着您的图片资源还必须能适应各种尺寸。例如，无论要应用到什么形状的按钮上，按钮背景都必须能适应。"></a>支持各种屏幕尺寸通常意味着您的图片资源还必须能适应各种尺寸。例如，无论要应用到什么形状的按钮上，按钮背景都必须能适应。</h4><h4 id="如果在可以更改尺寸的组件上使用了简单的图片，您很快就会发现显示效果多少有些不太理想，因为系统会在运行时平均地拉伸或收缩您的图片。解决方法为使用自动拉伸位图，这是一种格式特殊的-PNG-文件，其中会指明可以拉伸以及不可以拉伸的区域。"><a href="#如果在可以更改尺寸的组件上使用了简单的图片，您很快就会发现显示效果多少有些不太理想，因为系统会在运行时平均地拉伸或收缩您的图片。解决方法为使用自动拉伸位图，这是一种格式特殊的-PNG-文件，其中会指明可以拉伸以及不可以拉伸的区域。" class="headerlink" title="如果在可以更改尺寸的组件上使用了简单的图片，您很快就会发现显示效果多少有些不太理想，因为系统会在运行时平均地拉伸或收缩您的图片。解决方法为使用自动拉伸位图，这是一种格式特殊的 PNG 文件，其中会指明可以拉伸以及不可以拉伸的区域。"></a>如果在可以更改尺寸的组件上使用了简单的图片，您很快就会发现显示效果多少有些不太理想，因为系统会在运行时平均地拉伸或收缩您的图片。解决方法为使用自动拉伸位图，这是一种格式特殊的 PNG 文件，其中会指明可以拉伸以及不可以拉伸的区域。</h4><h4 id="9的制作，实际上就是在原图片上添加1px的边界，然后按照我们的需求，把对应的位置设置成黑色线，系统就会根据我们的实际需求进行拉伸。"><a href="#9的制作，实际上就是在原图片上添加1px的边界，然后按照我们的需求，把对应的位置设置成黑色线，系统就会根据我们的实际需求进行拉伸。" class="headerlink" title=".9的制作，实际上就是在原图片上添加1px的边界，然后按照我们的需求，把对应的位置设置成黑色线，系统就会根据我们的实际需求进行拉伸。"></a>.9的制作，实际上就是在原图片上添加1px的边界，然后按照我们的需求，把对应的位置设置成黑色线，系统就会根据我们的实际需求进行拉伸。</h4><hr>
<h3 id="9、普通图片处理"><a href="#9、普通图片处理" class="headerlink" title="9、普通图片处理"></a>9、普通图片处理</h3><p>稍后会详细介绍。</p>
<hr>
<h3 id="10、dimens使用"><a href="#10、dimens使用" class="headerlink" title="10、dimens使用"></a>10、dimens使用</h3><p><img src="http://img.blog.csdn.net/20170828100114675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="如上图，我将市面上各分辨率下的屏幕尺寸，取了平均数，算出对应的真实的屏幕像素密度，与理论要求的屏幕像素密度作了对比，比值在倒数第二列。发现：（干货要来了！）真实像素密度与理论像素密度的比值大致分为两类，取其平均数，一类在1-15左右，另一类则在0-89左右。巧了，它们两类正好各自对应w320dp和w360dp的宽度限定符！所以，dimens只需写两套即可（values-w320dp、values-w360dp），其name与真实数值的比值就是刚刚我们算出的两个平均数！-以后我们就不需要对应各种分辨率写多套dimens了，两套dimens即可。"><a href="#如上图，我将市面上各分辨率下的屏幕尺寸，取了平均数，算出对应的真实的屏幕像素密度，与理论要求的屏幕像素密度作了对比，比值在倒数第二列。发现：（干货要来了！）真实像素密度与理论像素密度的比值大致分为两类，取其平均数，一类在1-15左右，另一类则在0-89左右。巧了，它们两类正好各自对应w320dp和w360dp的宽度限定符！所以，dimens只需写两套即可（values-w320dp、values-w360dp），其name与真实数值的比值就是刚刚我们算出的两个平均数！-以后我们就不需要对应各种分辨率写多套dimens了，两套dimens即可。" class="headerlink" title="如上图，我将市面上各分辨率下的屏幕尺寸，取了平均数，算出对应的真实的屏幕像素密度，与理论要求的屏幕像素密度作了对比，比值在倒数第二列。发现：（干货要来了！）真实像素密度与理论像素密度的比值大致分为两类，取其平均数，一类在1.15左右，另一类则在0.89左右。巧了，它们两类正好各自对应w320dp和w360dp的宽度限定符！所以，dimens只需写两套即可（values-w320dp、values-w360dp），其name与真实数值的比值就是刚刚我们算出的两个平均数！ 以后我们就不需要对应各种分辨率写多套dimens了，两套dimens即可。"></a>如上图，我将市面上各分辨率下的屏幕尺寸，取了平均数，算出对应的真实的屏幕像素密度，与理论要求的屏幕像素密度作了对比，比值在倒数第二列。发现：<strong>（干货要来了！）真实像素密度与理论像素密度的比值大致分为两类，取其平均数，一类在1.15左右，另一类则在0.89左右。巧了，它们两类正好各自对应w320dp和w360dp的宽度限定符！所以，dimens只需写两套即可（values-w320dp、values-w360dp），其name与真实数值的比值就是刚刚我们算出的两个平均数！</strong> 以后我们就不需要对应各种分辨率写多套dimens了，两套dimens即可。</h4><h4 id="例如：在w320dp限定符下的dimens中，按照上表中求出的w320dp的比值平均数，将逻辑值转为实际值，name为理论值，后面对应真实值，在布局中按设计引用对应dimen值即可。"><a href="#例如：在w320dp限定符下的dimens中，按照上表中求出的w320dp的比值平均数，将逻辑值转为实际值，name为理论值，后面对应真实值，在布局中按设计引用对应dimen值即可。" class="headerlink" title="例如：在w320dp限定符下的dimens中，按照上表中求出的w320dp的比值平均数，将逻辑值转为实际值，name为理论值，后面对应真实值，在布局中按设计引用对应dimen值即可。"></a>例如：在w320dp限定符下的dimens中，按照上表中求出的w320dp的比值平均数，将逻辑值转为实际值，name为理论值，后面对应真实值，在布局中<strong>按设计</strong>引用对应dimen值即可。</h4><p><img src="http://img.blog.csdn.net/20170828100128985?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h2 id="五、图片处理"><a href="#五、图片处理" class="headerlink" title="五、图片处理"></a>五、图片处理</h2><h3 id="1、logo"><a href="#1、logo" class="headerlink" title="1、logo"></a>1、logo</h3><p><img src="http://img.blog.csdn.net/20170828100212161?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="logo需要3636、4848、7272、9696、144144、192192px，图片使用正方形形状，在某些机型上面，会自动显示为圆角正方形；"><a href="#logo需要3636、4848、7272、9696、144144、192192px，图片使用正方形形状，在某些机型上面，会自动显示为圆角正方形；" class="headerlink" title="logo需要3636、4848、7272、9696、144144、192192px，图片使用正方形形状，在某些机型上面，会自动显示为圆角正方形；"></a>logo需要36<em>36、48</em>48、72<em>72、96</em>96、144<em>144、192</em>192px，图片使用正方形形状，在某些机型上面，会自动显示为圆角正方形；</h4><h4 id="Android8-0以后，系统增加了logo点击效果和动画，可按以上尺寸制作圆形logo，但图片必须为正方形，圆形以外区域透明。"><a href="#Android8-0以后，系统增加了logo点击效果和动画，可按以上尺寸制作圆形logo，但图片必须为正方形，圆形以外区域透明。" class="headerlink" title="Android8.0以后，系统增加了logo点击效果和动画，可按以上尺寸制作圆形logo，但图片必须为正方形，圆形以外区域透明。"></a>Android8.0以后，系统增加了logo点击效果和动画，可按以上尺寸制作圆形logo，但图片必须为正方形，圆形以外区域透明。</h4><hr>
<h3 id="2、普通图片"><a href="#2、普通图片" class="headerlink" title="2、普通图片"></a>2、普通图片</h3><p><img src="http://img.blog.csdn.net/20170828100326564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170828100338109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="UI切图只需按照720-1280，4-7寸屏幕切图即可；"><a href="#UI切图只需按照720-1280，4-7寸屏幕切图即可；" class="headerlink" title="UI切图只需按照720*1280，4.7寸屏幕切图即可；"></a>UI切图只需按照720*1280，4.7寸屏幕切图即可；</h4><h4 id="应为iphone6等分辨率、尺寸、像素密度都与要求接近，可使用IOS的2x图代替。"><a href="#应为iphone6等分辨率、尺寸、像素密度都与要求接近，可使用IOS的2x图代替。" class="headerlink" title="应为iphone6等分辨率、尺寸、像素密度都与要求接近，可使用IOS的2x图代替。"></a>应为iphone6等分辨率、尺寸、像素密度都与要求接近，可使用IOS的2x图代替。</h4><p><img src="http://img.blog.csdn.net/20170828100409932?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h3 id="3、纯色图、-9图"><a href="#3、纯色图、-9图" class="headerlink" title="3、纯色图、.9图"></a>3、纯色图、.9图</h3><h4 id="纯色按钮或渐变按钮可使用代码设置颜色或-9图实现，不必用图片作为背景。"><a href="#纯色按钮或渐变按钮可使用代码设置颜色或-9图实现，不必用图片作为背景。" class="headerlink" title="纯色按钮或渐变按钮可使用代码设置颜色或.9图实现，不必用图片作为背景。"></a>纯色按钮或渐变按钮可使用代码设置颜色或.9图实现，不必用图片作为背景。</h4><hr>
<h3 id="4、动画、自定义view、shape"><a href="#4、动画、自定义view、shape" class="headerlink" title="4、动画、自定义view、shape"></a>4、动画、自定义view、shape</h3><h4 id="可以使用代码进行控制和展示多种视图，如patch动画替代帧动画。"><a href="#可以使用代码进行控制和展示多种视图，如patch动画替代帧动画。" class="headerlink" title="可以使用代码进行控制和展示多种视图，如patch动画替代帧动画。"></a>可以使用代码进行控制和展示多种视图，如patch动画替代帧动画。</h4><hr>
<h3 id="5、ImageView的ScaleType"><a href="#5、ImageView的ScaleType" class="headerlink" title="5、ImageView的ScaleType"></a>5、ImageView的ScaleType</h3><h4 id="关于ScaleType请参考这里-点击打开"><a href="#关于ScaleType请参考这里-点击打开" class="headerlink" title="关于ScaleType请参考这里 点击打开"></a>关于ScaleType请参考这里 <a href="http://blog.csdn.net/jiashuai94/article/details/77673625" target="_blank" rel="noopener">点击打开</a></h4><hr>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1、代码适配"><a href="#1、代码适配" class="headerlink" title="1、代码适配"></a>1、代码适配</h3><h4 id="在代码中使用Google提供的API对设备的屏幕宽度进行测量，然后按照需求进行设置。"><a href="#在代码中使用Google提供的API对设备的屏幕宽度进行测量，然后按照需求进行设置。" class="headerlink" title="在代码中使用Google提供的API对设备的屏幕宽度进行测量，然后按照需求进行设置。"></a>在代码中使用Google提供的API对设备的屏幕宽度进行测量，然后按照需求进行设置。</h4><h4 id="几个主要使用的API："><a href="#几个主要使用的API：" class="headerlink" title="几个主要使用的API："></a>几个主要使用的API：</h4><h4 id="对于当前控件的宽高设置，需要做的操作是首先要获取到该控件的父控件，使用父控件对当前控件的宽高进行设置操作！"><a href="#对于当前控件的宽高设置，需要做的操作是首先要获取到该控件的父控件，使用父控件对当前控件的宽高进行设置操作！" class="headerlink" title="对于当前控件的宽高设置，需要做的操作是首先要获取到该控件的父控件，使用父控件对当前控件的宽高进行设置操作！"></a>对于当前控件的宽高设置，需要做的操作是首先要获取到该控件的父控件，使用父控件对当前控件的宽高进行设置操作！</h4><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DisplayMetrics metrics = new DisplayMetrics ();</span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">手机对应的宽高：</span><br><span class="line">Constants.screenHeight= metrics.heightDixels;</span><br><span class="line">Constants.screenWidth= metrics.widthDixels;</span><br><span class="line">RelativeLayout.LayoutParams=new RelativeLayout.LayoutParams();</span><br><span class="line"></span><br><span class="line">(int)( Constants.screenHeight*0.5+0.5f);</span><br><span class="line">(int)( Constants.screenWidth *0.5+0.5f);</span><br></pre></td></tr></table></figure>
<h4 id="在上面的两个计算操作中最后加上0-5f的作用是：进行float强转到int类型的时候会出现都是精度的问题。当使用Java代码进行宽高设置的时候，假如出现320-2dp这样的数据此时直接进行int得到的值是320；但是假如出现320-7这样的数据的时候，由于int的计算规则，会直接强转为320，但是从实际出发，这个时候的值取321更为合适。"><a href="#在上面的两个计算操作中最后加上0-5f的作用是：进行float强转到int类型的时候会出现都是精度的问题。当使用Java代码进行宽高设置的时候，假如出现320-2dp这样的数据此时直接进行int得到的值是320；但是假如出现320-7这样的数据的时候，由于int的计算规则，会直接强转为320，但是从实际出发，这个时候的值取321更为合适。" class="headerlink" title="在上面的两个计算操作中最后加上0.5f的作用是：进行float强转到int类型的时候会出现都是精度的问题。当使用Java代码进行宽高设置的时候，假如出现320.2dp这样的数据此时直接进行int得到的值是320；但是假如出现320.7这样的数据的时候，由于int的计算规则，会直接强转为320，但是从实际出发，这个时候的值取321更为合适。"></a>在上面的两个计算操作中最后加上0.5f的作用是：进行float强转到int类型的时候会出现都是精度的问题。当使用Java代码进行宽高设置的时候，假如出现320.2dp这样的数据此时直接进行int得到的值是320；但是假如出现320.7这样的数据的时候，由于int的计算规则，会直接强转为320，但是从实际出发，这个时候的值取321更为合适。</h4><h4 id="所以在计算的最后直接加0-5，这样一来，320-2-0-5-320-7，进行数据的强转操作得到的数据是320，320-7-0-5-321-2，进行数据强转操作得到的数据是321，这样一来得到的数据就和实际预想的更为接近！！"><a href="#所以在计算的最后直接加0-5，这样一来，320-2-0-5-320-7，进行数据的强转操作得到的数据是320，320-7-0-5-321-2，进行数据强转操作得到的数据是321，这样一来得到的数据就和实际预想的更为接近！！" class="headerlink" title="所以在计算的最后直接加0.5，这样一来，320.2+0.5=320.7，进行数据的强转操作得到的数据是320，320.7+0.5=321.2，进行数据强转操作得到的数据是321，这样一来得到的数据就和实际预想的更为接近！！"></a>所以在计算的最后直接加0.5，这样一来，320.2+0.5=320.7，进行数据的强转操作得到的数据是320，320.7+0.5=321.2，进行数据强转操作得到的数据是321，这样一来得到的数据就和实际预想的更为接近！！</h4><hr>
<h3 id="2、接口配合"><a href="#2、接口配合" class="headerlink" title="2、接口配合"></a>2、接口配合</h3><h4 id="本地加载图片前判断手机分辨率或像素密度，向服务器请求对应级别图片。"><a href="#本地加载图片前判断手机分辨率或像素密度，向服务器请求对应级别图片。" class="headerlink" title="本地加载图片前判断手机分辨率或像素密度，向服务器请求对应级别图片。"></a>本地加载图片前判断手机分辨率或像素密度，向服务器请求对应级别图片。</h4><hr>
<p>由于时间匆忙和水平有限，文章中不免错误和不足的地方，希望大家予以指出，一起进步！</p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/12/Android项目从立项到上线——修仙之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/Android项目从立项到上线——修仙之路/" itemprop="url">Android项目从立项到上线————修仙之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-12T00:00:00+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！"><a href="#最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！" class="headerlink" title="最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！"></a>最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！</h4><h4 id="接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github："><a href="#接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github：" class="headerlink" title="接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github："></a>接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github：</h4><ul>
<li>Material Design风格项目  <a href="https://github.com/shuaijia/MaterialDesignProject" target="_blank" rel="noopener">点击前往</a> 喜欢就给个star^_^</li>
<li>UI、Base、网络等封装库项目 <a href="https://github.com/shuaijia/JSBaseDemo" target="_blank" rel="noopener">点击前往</a>    喜欢也给个star喽</li>
</ul>
<h4 id="先上图来看看吧："><a href="#先上图来看看吧：" class="headerlink" title="先上图来看看吧："></a>先上图来看看吧：</h4><p><img src="http://img.blog.csdn.net/20170906094324145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="项目采用MVP-Retrofit-RxJava-Gson-Glide-Material-Design设计"><a href="#项目采用MVP-Retrofit-RxJava-Gson-Glide-Material-Design设计" class="headerlink" title="项目采用MVP+Retrofit+RxJava+Gson+Glide+Material Design设计"></a>项目采用<strong>MVP+Retrofit+RxJava+Gson+Glide+Material Design</strong>设计</h4><h4 id="同时也使用了EventBus事件总线、GreenDao数据库、SurfaceView-MediaPlayer视频播放器等主要技术。"><a href="#同时也使用了EventBus事件总线、GreenDao数据库、SurfaceView-MediaPlayer视频播放器等主要技术。" class="headerlink" title="同时也使用了EventBus事件总线、GreenDao数据库、SurfaceView+MediaPlayer视频播放器等主要技术。"></a>同时也使用了<strong>EventBus事件总线</strong>、<strong>GreenDao数据库</strong>、<strong>SurfaceView+MediaPlayer视频播放器</strong>等主要技术。</h4><h4 id="ok！项目就简单介绍到这里，接下来开始我们的修仙之路。"><a href="#ok！项目就简单介绍到这里，接下来开始我们的修仙之路。" class="headerlink" title="ok！项目就简单介绍到这里，接下来开始我们的修仙之路。"></a>ok！项目就简单介绍到这里，接下来开始我们的修仙之路。</h4><hr>
<p><img src="http://img.blog.csdn.net/20170906095022010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="1、项目整体分析"><a href="#1、项目整体分析" class="headerlink" title="1、项目整体分析"></a>1、项目整体分析</h2><h3 id="a、UI风格"><a href="#a、UI风格" class="headerlink" title="a、UI风格"></a>a、UI风格</h3><h4 id="logo"><a href="#logo" class="headerlink" title="logo"></a>logo</h4><h4 id="主题风格："><a href="#主题风格：" class="headerlink" title="主题风格："></a>主题风格：</h4><ul>
<li>Material Design</li>
<li>仿ios</li>
<li>主界面–侧拉</li>
<li>主界面–仿微信 选项卡等</li>
</ul>
<h3 id="b、技术方案"><a href="#b、技术方案" class="headerlink" title="b、技术方案"></a>b、技术方案</h3><h4 id="整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。"><a href="#整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。" class="headerlink" title="整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。"></a>整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。</h4><ul>
<li>项目架构</li>
<li>网络框架 </li>
<li>图片处理</li>
<li>数据处理/接口格式</li>
<li>三方使用：统计、推送、更新等</li>
</ul>
<h3 id="c、可行性分析"><a href="#c、可行性分析" class="headerlink" title="c、可行性分析"></a>c、可行性分析</h3><h4 id="邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。"><a href="#邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。" class="headerlink" title="邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。"></a>邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。</h4><h3 id="d、工期"><a href="#d、工期" class="headerlink" title="d、工期"></a>d、工期</h3><h4 id="根据项目需求和技术方案，给出开发时长；"><a href="#根据项目需求和技术方案，给出开发时长；" class="headerlink" title="根据项目需求和技术方案，给出开发时长；"></a>根据项目需求和技术方案，给出开发时长；</h4><h4 id="根据工期要求，可适当调整技术方案。"><a href="#根据工期要求，可适当调整技术方案。" class="headerlink" title="根据工期要求，可适当调整技术方案。"></a>根据工期要求，可适当调整技术方案。</h4><h3 id="e、测试用例"><a href="#e、测试用例" class="headerlink" title="e、测试用例"></a>e、测试用例</h3><h4 id="测试人员开始整理、编写测试用例和项目标准文档；"><a href="#测试人员开始整理、编写测试用例和项目标准文档；" class="headerlink" title="测试人员开始整理、编写测试用例和项目标准文档；"></a>测试人员开始整理、编写测试用例和项目标准文档；</h4><h4 id="个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。"><a href="#个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。" class="headerlink" title="个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。"></a><em>个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。</em></h4><hr>
<h2 id="2、开发规范"><a href="#2、开发规范" class="headerlink" title="2、开发规范"></a>2、开发规范</h2><h4 id="其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范："><a href="#其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范：" class="headerlink" title="其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范："></a>其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范：</h4><h4 id="以自己项目为例，涉及到以下几项："><a href="#以自己项目为例，涉及到以下几项：" class="headerlink" title="以自己项目为例，涉及到以下几项："></a>以自己项目为例，涉及到以下几项：</h4><ul>
<li>文档规范</li>
<li>资源命名规范</li>
<li>代码命名规范</li>
<li>代码注释规范</li>
<li>代码风格规范</li>
<li>服务器数据规范  等</li>
</ul>
<h3 id="a、文档"><a href="#a、文档" class="headerlink" title="a、文档"></a>a、文档</h3><h4 id="重要有以下几个文档："><a href="#重要有以下几个文档：" class="headerlink" title="重要有以下几个文档："></a>重要有以下几个文档：</h4><ol>
<li>需求文档</li>
<li>产品原型图</li>
<li>完整UI图</li>
<li>接口文档</li>
<li>核心技术文档</li>
<li>重点逻辑文档</li>
<li>程序框架图</li>
<li>ER图、数据字典、类图等</li>
<li>测试文档<h3 id="b、资源文件命名规范"><a href="#b、资源文件命名规范" class="headerlink" title="b、资源文件命名规范"></a>b、资源文件命名规范</h3><h4 id="名字全部小写，最好不用数字，全部英文，单词中间下划线隔开"><a href="#名字全部小写，最好不用数字，全部英文，单词中间下划线隔开" class="headerlink" title="名字全部小写，最好不用数字，全部英文，单词中间下划线隔开"></a><strong>名字全部小写，最好不用数字，全部英文，单词中间下划线隔开</strong></h4></li>
</ol>
<h4 id="、drawable、anim等文件夹下"><a href="#、drawable、anim等文件夹下" class="headerlink" title="~、drawable、anim等文件夹下"></a>~、drawable、anim等文件夹下</h4><p>名称结构为“技术点<em>模块点</em>空间类型_功能名”结构，技术点主要有：selector、translate、alpha、scale等，模块名主要有：login、pay、mine、setting等，控件类型主要有：button、textview、imageview、dialog等，功能名主要有：findpwd、request、back、next等。<br><img src="http://img.blog.csdn.net/20170906134436576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、drawable-xhdpi等图片资源"><a href="#、drawable-xhdpi等图片资源" class="headerlink" title="~、drawable-xhdpi等图片资源"></a>~、drawable-xhdpi等图片资源</h4><p>名称为“技术点<em>模块点</em>功能名”结构，技术点主要有：activity、fragment、item、include等，模块点主要有：login、setting、mine、pay等，功能名主要有：head、title、back、sure等。<br><img src="http://img.blog.csdn.net/20170906134634239?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、layout"><a href="#、layout" class="headerlink" title="~、layout"></a>~、layout</h4><p>布局名称为“技术点<em>模块</em>功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。<br><img src="http://img.blog.csdn.net/20170906134838331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、values"><a href="#、values" class="headerlink" title="~、values"></a>~、values</h4><p>布局名称为“技术点<em>模块</em>功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。<br><img src="http://img.blog.csdn.net/20170906134925206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="c、代码命名规范"><a href="#c、代码命名规范" class="headerlink" title="c、代码命名规范"></a>c、代码命名规范</h3><h4 id="、包名"><a href="#、包名" class="headerlink" title="~、包名"></a>~、包名</h4><p>包名为“根包名.技术点名.模块名”结构，<strong>全部小写</strong><br><img src="http://img.blog.csdn.net/20170906135230342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、类名"><a href="#、类名" class="headerlink" title="~、类名"></a>~、类名</h4><h4 id="采用-大驼峰-命名法，单词直接拼接，所有单词首字母大写"><a href="#采用-大驼峰-命名法，单词直接拼接，所有单词首字母大写" class="headerlink" title="采用 大驼峰 命名法，单词直接拼接，所有单词首字母大写"></a>采用 <strong>大驼峰</strong> 命名法，单词直接拼接，所有单词首字母大写</h4><p>类名为“业务模块名 执行操作名 技术点名”结构，业务模块名主要有：home、lession、net、login，pay等，操作名主要有：Get、Set、Request、Login等，技术点名主要有：Activity、Fragment、View、Adapter等。<br><img src="http://img.blog.csdn.net/20170906135438992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、普通变量"><a href="#、普通变量" class="headerlink" title="~、普通变量"></a>~、普通变量</h4><h4 id="采用-小驼峰-命名法，第一个单词首字母小写，其他单词首字母大写。"><a href="#采用-小驼峰-命名法，第一个单词首字母小写，其他单词首字母大写。" class="headerlink" title="采用 小驼峰 命名法，第一个单词首字母小写，其他单词首字母大写。"></a>采用 <strong>小驼峰</strong> 命名法，第一个单词首字母小写，其他单词首字母大写。</h4><p>普通变量为“名字简写 类型 功能名”结构，名字简写有：js等，类型主要有：Int、Double、Boolean、String、Char等，功能名有：Login、Number、Content等。<br><img src="http://img.blog.csdn.net/20170906135621037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、常亮"><a href="#、常亮" class="headerlink" title="~、常亮"></a>~、常亮</h4><h4 id="所有字母全部大写，中间下划线隔开"><a href="#所有字母全部大写，中间下划线隔开" class="headerlink" title="所有字母全部大写，中间下划线隔开"></a>所有字母全部大写，中间下划线隔开</h4><p>常量为“功能名_标识”结构，功能名主要有：LOGIN、REQUEST、PERSONINFO等，标识有SUCCESS、ERROR、URL等。<br><img src="http://img.blog.csdn.net/20170906135818518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="、方法名"><a href="#、方法名" class="headerlink" title="~、方法名"></a>~、方法名</h4><p>名字能体现出功能即可。不再累赘重述。</p>
<hr>
<h2 id="3、数据-接口定义"><a href="#3、数据-接口定义" class="headerlink" title="3、数据/接口定义"></a>3、数据/接口定义</h2><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ol>
<li>服务器返回数据采用json格式</li>
<li>json数据中无数据，必须返回空数组或空字符串，不可返回null</li>
<li>Android端使用gson或fastjson或jackson等三方解析工具解析</li>
<li>不建议使用官方JSONObject解析，容易出错</li>
<li>实体类属性名与json中字段名完全一致</li>
<li>json中字段名全部使用英文，不可英文、拼音夹杂</li>
<li>用户表识建议使用Cookie</li>
<li>建议使用POST解析，它对参数数量没有要求，也比较安全</li>
<li>为了传输安全，使用https请求   等</li>
<li>完善接口文档，建议每一版对应一个完整接口文档</li>
</ol>
<hr>
<h2 id="4、屏幕适配"><a href="#4、屏幕适配" class="headerlink" title="4、屏幕适配"></a>4、屏幕适配</h2><h4 id="安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的7201280和10801920手机进行适配，同时对于其他类型手机也要适配。"><a href="#安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的7201280和10801920手机进行适配，同时对于其他类型手机也要适配。" class="headerlink" title="安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的7201280和10801920手机进行适配，同时对于其他类型手机也要适配。"></a>安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的720<em>1280和1080</em>1920手机进行适配，同时对于其他类型手机也要适配。</h4><h4 id="关于屏幕适配，之前写过一个Android屏幕完美适配方案，点击前往，这里不再重复表述。"><a href="#关于屏幕适配，之前写过一个Android屏幕完美适配方案，点击前往，这里不再重复表述。" class="headerlink" title="关于屏幕适配，之前写过一个Android屏幕完美适配方案，点击前往，这里不再重复表述。"></a>关于屏幕适配，之前写过一个<strong>Android屏幕完美适配方案</strong>，<a href="http://blog.csdn.net/jiashuai94/article/details/77639511" target="_blank" rel="noopener">点击前往</a>，这里不再重复表述。</h4><hr>
<h2 id="5、程序架构MVP"><a href="#5、程序架构MVP" class="headerlink" title="5、程序架构MVP"></a>5、程序架构MVP</h2><p><img src="http://img.blog.csdn.net/20170907092553745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="上图介绍："><a href="#上图介绍：" class="headerlink" title="上图介绍："></a>上图介绍：</h3><h4 id="Contract：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。"><a href="#Contract：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。" class="headerlink" title="Contract：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。"></a><strong>Contract：</strong>契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。</h4><h4 id="ViewInterface：-view层接口，定义了view中的UI操作"><a href="#ViewInterface：-view层接口，定义了view中的UI操作" class="headerlink" title="ViewInterface： view层接口，定义了view中的UI操作"></a><strong>ViewInterface：</strong> view层接口，定义了view中的UI操作</h4><h4 id="ModelInterface：-model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等"><a href="#ModelInterface：-model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等" class="headerlink" title="ModelInterface： model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等"></a><strong>ModelInterface：</strong> model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等</h4><h4 id="CallbackInterface：-model层操作数据完成后的回调"><a href="#CallbackInterface：-model层操作数据完成后的回调" class="headerlink" title="CallbackInterface： model层操作数据完成后的回调"></a><strong>CallbackInterface：</strong> model层操作数据完成后的回调</h4><h4 id="BasePersenter：-Persenter父类，主要是对相关view的获取，销毁等操作"><a href="#BasePersenter：-Persenter父类，主要是对相关view的获取，销毁等操作" class="headerlink" title="BasePersenter： Persenter父类，主要是对相关view的获取，销毁等操作"></a><strong>BasePersenter：</strong> Persenter父类，主要是对相关view的获取，销毁等操作</h4><h4 id="View：-view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应"><a href="#View：-view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应" class="headerlink" title="View： view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应"></a><strong>View：</strong> view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应</h4><h4 id="Model：-model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack"><a href="#Model：-model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack" class="headerlink" title="Model： model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack"></a><strong>Model：</strong> model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack</h4><h4 id="Persenter：-persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示"><a href="#Persenter：-persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示" class="headerlink" title="Persenter： persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示"></a><strong>Persenter：</strong> persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示</h4><h3 id="MVP："><a href="#MVP：" class="headerlink" title="MVP："></a>MVP：</h3><h4 id="MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。"><a href="#MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。" class="headerlink" title="MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。"></a>MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。</h4><h4 id="使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要"><a href="#使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要" class="headerlink" title="使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要"></a>使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要</h4><h4 id="现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。"><a href="#现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。" class="headerlink" title="现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。"></a><strong>现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。</strong></h4><hr>
<h2 id="6、package划分"><a href="#6、package划分" class="headerlink" title="6、package划分"></a>6、package划分</h2><p><img src="http://img.blog.csdn.net/20170907103058711?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。"><a href="#如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。" class="headerlink" title="如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。"></a>如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。</h4><h4 id="总之，我们划分包时：以功能模块为主，以技术点为辅。"><a href="#总之，我们划分包时：以功能模块为主，以技术点为辅。" class="headerlink" title="总之，我们划分包时：以功能模块为主，以技术点为辅。"></a>总之，我们划分包时：<strong>以功能模块为主，以技术点为辅</strong>。</h4><h4 id="希望能对大家有用"><a href="#希望能对大家有用" class="headerlink" title="希望能对大家有用"></a>希望能对大家有用</h4><hr>
<h2 id="7、Base、Util、UI类封装"><a href="#7、Base、Util、UI类封装" class="headerlink" title="7、Base、Util、UI类封装"></a>7、Base、Util、UI类封装</h2><h3 id="A、Base类"><a href="#A、Base类" class="headerlink" title="A、Base类"></a>A、Base类</h3><ul>
<li>BaseApplication</li>
<li>BaseActivity</li>
<li>BaseFragment</li>
<li><p>BasePresenter 等</p>
<h4 id="a、BaseApplication："><a href="#a、BaseApplication：" class="headerlink" title="a、BaseApplication："></a>a、<strong>BaseApplication</strong>：</h4><h4 id="主要进行一些例如：三方配置、热更新加载、文件配置、数据库配置等准备工作；同时也许定义全局性变量：如Application的Context、网络状态、主线程Looper、主线程Handler等。"><a href="#主要进行一些例如：三方配置、热更新加载、文件配置、数据库配置等准备工作；同时也许定义全局性变量：如Application的Context、网络状态、主线程Looper、主线程Handler等。" class="headerlink" title="主要进行一些例如：三方配置、热更新加载、文件配置、数据库配置等准备工作；同时也许定义全局性变量：如Application的Context、网络状态、主线程Looper、主线程Handler等。"></a>主要进行一些例如：<strong>三方配置</strong>、<strong>热更新加载</strong>、<strong>文件配置</strong>、<strong>数据库配置</strong>等准备工作；同时也许定义全局性变量：如<strong>Application的Context</strong>、<strong>网络状态</strong>、<strong>主线程Looper</strong>、<strong>主线程Handler</strong>等。</h4><h4 id="b、BaseActivity："><a href="#b、BaseActivity：" class="headerlink" title="b、BaseActivity："></a>b、<strong>BaseActivity</strong>：</h4><h4 id="封装为抽象类，将各任务抽取成方法，有子类实现：比如findViewById-initView-、initData、setListener等；"><a href="#封装为抽象类，将各任务抽取成方法，有子类实现：比如findViewById-initView-、initData、setListener等；" class="headerlink" title="封装为抽象类，将各任务抽取成方法，有子类实现：比如findViewById(initView)、initData、setListener等；"></a>封装为抽象类，将各任务抽取成方法，有子类实现：比如<strong>findViewById(initView)</strong>、<strong>initData</strong>、<strong>setListener</strong>等；</h4><h4 id="对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。"><a href="#对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。" class="headerlink" title="对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。"></a>对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。</h4><h4 id="项目为MVP结构，所以设置了View和Presenter的泛型，如："><a href="#项目为MVP结构，所以设置了View和Presenter的泛型，如：" class="headerlink" title="项目为MVP结构，所以设置了View和Presenter的泛型，如："></a>项目为MVP结构，所以设置了View和Presenter的泛型，如：</h4><h4 id="其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。"><a href="#其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。" class="headerlink" title="其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。"></a>其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。</h4><p><img src="http://img.blog.csdn.net/20170911093023497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="c、BaseFragment："><a href="#c、BaseFragment：" class="headerlink" title="c、BaseFragment："></a>c、<strong>BaseFragment</strong>：</h4><h4 id="BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；"><a href="#BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；" class="headerlink" title="BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；"></a>BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；</h4><h4 id="创建createView-创建跟视图view-、initChildView-子view-findViewById-、initData-加载数据-抽象方法"><a href="#创建createView-创建跟视图view-、initChildView-子view-findViewById-、initData-加载数据-抽象方法" class="headerlink" title="创建createView(创建跟视图view)、initChildView(子view findViewById)、initData(加载数据)抽象方法"></a>创建<strong>createView</strong>(创建跟视图view)、<strong>initChildView</strong>(子view findViewById)、<strong>initData</strong>(加载数据)抽象方法</h4><h4 id="d、BasePresenter："><a href="#d、BasePresenter：" class="headerlink" title="d、BasePresenter："></a>d、<strong>BasePresenter</strong>：</h4><p><img src="http://img.blog.csdn.net/20170911102506210?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。"><a href="#BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。" class="headerlink" title="BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。"></a>BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。</h4></li>
</ul>
<h3 id="B、Utils类"><a href="#B、Utils类" class="headerlink" title="B、Utils类"></a>B、Utils类</h3><h4 id="只列举一些常用的工具类："><a href="#只列举一些常用的工具类：" class="headerlink" title="只列举一些常用的工具类："></a>只列举一些常用的工具类：</h4><ul>
<li>SharedPreferenceUtils</li>
<li>ToastUtils</li>
<li>StorageUtils</li>
<li>FileUtils</li>
<li>NetUtils</li>
<li>deviceUtils</li>
<li>DateUtils</li>
<li>LogUtils</li>
<li>AppUtils 等</li>
</ul>
<h3 id="C、UI类"><a href="#C、UI类" class="headerlink" title="C、UI类"></a>C、UI类</h3><h4 id="只列举一些常用的View类"><a href="#只列举一些常用的View类" class="headerlink" title="只列举一些常用的View类"></a>只列举一些常用的View类</h4><ul>
<li>下拉刷新、上拉加载</li>
<li>圆形ImageView</li>
<li>自定义Dialog</li>
<li>Banner</li>
<li>自定义ScrollView</li>
<li>自定义RecyclerView  </li>
<li>项目相关的自定义View  等</li>
</ul>
<hr>
<h2 id="8、数据库"><a href="#8、数据库" class="headerlink" title="8、数据库"></a>8、数据库</h2><h4 id="关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。"><a href="#关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。" class="headerlink" title="关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。"></a>关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。</h4><h4 id="但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；"><a href="#但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；" class="headerlink" title="但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；"></a>但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；</h4><h4 id="所以我们只介绍几款流行的数据库框架："><a href="#所以我们只介绍几款流行的数据库框架：" class="headerlink" title="所以我们只介绍几款流行的数据库框架："></a>所以我们只介绍几款流行的数据库框架：</h4><ul>
<li>GreenDao</li>
<li>OrmLite</li>
<li>LitePal</li>
<li>Realm</li>
</ul>
<h3 id="GreenDao："><a href="#GreenDao：" class="headerlink" title="GreenDao："></a>GreenDao：</h3><h4 id="特点：1-存取速度快-2-支持数据库加密-3-轻量级-4-激活实体-5-支持缓存-6-代码自动生成"><a href="#特点：1-存取速度快-2-支持数据库加密-3-轻量级-4-激活实体-5-支持缓存-6-代码自动生成" class="headerlink" title="特点：1.存取速度快; 2.支持数据库加密; 3.轻量级; 4.激活实体; 5.支持缓存; 6.代码自动生成"></a>特点：1.存取速度快; 2.支持数据库加密; 3.轻量级; 4.激活实体; 5.支持缓存; 6.代码自动生成</h4><h4 id="地址：https-github-com-greenrobot-greenDAO"><a href="#地址：https-github-com-greenrobot-greenDAO" class="headerlink" title="地址：https://github.com/greenrobot/greenDAO"></a>地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">https://github.com/greenrobot/greenDAO</a></h4><h3 id="OrmLite："><a href="#OrmLite：" class="headerlink" title="OrmLite："></a>OrmLite：</h3><h4 id="优点：-1-轻量级；2-使用简单，易上手；3-封装完善；4-文档全面。缺点：1-基于反射，效率较低（本人还没有觉得效率低）；2-缺少中文翻译文档"><a href="#优点：-1-轻量级；2-使用简单，易上手；3-封装完善；4-文档全面。缺点：1-基于反射，效率较低（本人还没有觉得效率低）；2-缺少中文翻译文档" class="headerlink" title="优点： 1.轻量级；2.使用简单，易上手；3.封装完善；4.文档全面。缺点：1.基于反射，效率较低（本人还没有觉得效率低）；2.缺少中文翻译文档"></a>优点： 1.轻量级；2.使用简单，易上手；3.封装完善；4.文档全面。缺点：1.基于反射，效率较低（本人还没有觉得效率低）；2.缺少中文翻译文档</h4><h4 id="jar包地址：http-ormlite-com-releases"><a href="#jar包地址：http-ormlite-com-releases" class="headerlink" title="jar包地址：http://ormlite.com/releases/"></a>jar包地址：<a href="http://ormlite.com/releases/" target="_blank" rel="noopener">http://ormlite.com/releases/</a></h4><h3 id="LitePal："><a href="#LitePal：" class="headerlink" title="LitePal："></a>LitePal：</h3><h4 id="LitePal-框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。"><a href="#LitePal-框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。" class="headerlink" title="LitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。"></a>LitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。</h4><h4 id="地址：https-github-com-LitePalFramework-LitePal"><a href="#地址：https-github-com-LitePalFramework-LitePal" class="headerlink" title="地址：https://github.com/LitePalFramework/LitePal"></a>地址：<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></h4><h3 id="Realm："><a href="#Realm：" class="headerlink" title="Realm："></a>Realm：</h3><h4 id="1-易用：Ream-不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。"><a href="#1-易用：Ream-不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。" class="headerlink" title="1.易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。"></a>1.易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。</h4><h4 id="2-快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。"><a href="#2-快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。" class="headerlink" title="2.快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。"></a>2.快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。</h4><h4 id="3-跨平台：Realm-支持-iOS-amp-OS-X-Objective‑C-amp-Swift-amp-Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。"><a href="#3-跨平台：Realm-支持-iOS-amp-OS-X-Objective‑C-amp-Swift-amp-Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。" class="headerlink" title="3.跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。"></a>3.跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。</h4><h4 id="4-高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性"><a href="#4-高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性" class="headerlink" title="4.高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性"></a>4.高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性</h4><h4 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5.可视化"></a>5.可视化</h4><h4 id="git地址：https-github-com-realm-realm-java"><a href="#git地址：https-github-com-realm-realm-java" class="headerlink" title="git地址：https://github.com/realm/realm-java"></a>git地址：<a href="https://github.com/realm/realm-java" target="_blank" rel="noopener">https://github.com/realm/realm-java</a></h4><h4 id="官网：https-realm-io-docs-java-latest-getting-started"><a href="#官网：https-realm-io-docs-java-latest-getting-started" class="headerlink" title="官网：https://realm.io/docs/java/latest/#getting-started"></a>官网：<a href="https://realm.io/docs/java/latest/#getting-started" target="_blank" rel="noopener">https://realm.io/docs/java/latest/#getting-started</a></h4><h4 id="自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。"><a href="#自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。" class="headerlink" title="自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。"></a>自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。</h4><hr>
<h2 id="9、图片处理"><a href="#9、图片处理" class="headerlink" title="9、图片处理"></a>9、图片处理</h2><h4 id="之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。"><a href="#之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。" class="headerlink" title="之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。"></a>之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。</h4><h4 id="但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点："><a href="#但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点：" class="headerlink" title="但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点："></a>但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点：</h4><h3 id="ImageLoader："><a href="#ImageLoader：" class="headerlink" title="ImageLoader："></a>ImageLoader：</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>多线程下载，线程管理。</li>
<li>多级缓存架构设计和策略，内存缓存，磁盘缓存，缓存有效性处理。</li>
<li>图片压缩，特效处理，动画处理。</li>
<li>复杂网络情况下下载图片策略，例如弱网络等。</li>
<li>内存管理，lru 算法、对象引用、GC回收等优化。<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>时间久，官方不再维护，出现bug需要自己修复。</li>
</ul>
<h3 id="Glide："><a href="#Glide：" class="headerlink" title="Glide："></a>Glide：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我<strong>建议传参的时候传递Activity 和 Fragment给Glide，而不是Context</strong>。</li>
<li>Glide可以加载GIF动态图。</li>
<li>Glide缓存的是跟ImageView尺寸相同的。Glide的这种方式优点是加载显示非常快。</li>
<li>默认使用HttpUrlConnection下载图片，可以配置为OkHttp或者Volley下载，也可以自定义下载方式。</li>
<li>默认使用手机内置存储进行磁盘缓存，可以配置为外部存储，可以配置缓存大小，图片池大小。</li>
<li>默认使用两个线程池来分别执行读取缓存和下载任务，都可以自定义。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>Glide加载的图片质量要差于Picasso，这是因为Glide默认的Bitmap格式是RGB_565，比ARGB_8888格式的内存开销要小一半。</li>
</ul>
<h3 id="Picasso："><a href="#Picasso：" class="headerlink" title="Picasso："></a>Picasso：</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>在adapter中需要取消已经不在视野范围的ImageView图片资源的加载，否则会导致图片错位，Picasso已经解决了这个问题。</li>
<li>使用复杂的图片压缩转换来尽可能的减少内存消耗</li>
<li>自带内存和硬盘二级缓存功能</li>
</ul>
<h3 id="Fresco："><a href="#Fresco：" class="headerlink" title="Fresco："></a>Fresco：</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><p>最大的优势便在于5.0以下(最低2.3) bitmap的加载，在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem)，而且图片不显示时，占用的内存会自动被释放，这会使APP更加流畅，减少因图片内存占用而引发的OOM。5.0以后的系统默认存储在Ashmem区了</p>
</li>
<li><p>图片的渐进式呈现，图片先呈现大致的轮廓，然后随着图片下载的继续，逐渐成仙清晰的图片，这对于慢网络对说，用户体验更好。</p>
</li>
<li><p>支持加载Git动态图和Webp格式的图片。</p>
</li>
</ul>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>框架体积比较大，3M左右，会增加APK的大小。<h4 id="总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。"><a href="#总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。" class="headerlink" title="总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。"></a>总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。</h4></li>
</ul>
<hr>
<h2 id="10、网络框架"><a href="#10、网络框架" class="headerlink" title="10、网络框架"></a>10、网络框架</h2><h4 id="上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。"><a href="#上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。" class="headerlink" title="上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。"></a>上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含<em>请求方式</em>、<em>url</em>、<em>参数</em>、<em>解析类</em>、<em>是否缓存</em>、<em>缓存时长</em>等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。</h4><h4 id="但现在市面上最流行的是Retrofit-RxJava-Gson，接下来我们大概介绍一下："><a href="#但现在市面上最流行的是Retrofit-RxJava-Gson，接下来我们大概介绍一下：" class="headerlink" title="但现在市面上最流行的是Retrofit+RxJava+Gson，接下来我们大概介绍一下："></a>但现在市面上最流行的是Retrofit+RxJava+Gson，接下来我们大概介绍一下：</h4><h3 id="a、添加依赖"><a href="#a、添加依赖" class="headerlink" title="a、添加依赖"></a>a、添加依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;io.reactivex:rxjava:x.y.z&apos;</span><br><span class="line">compile &apos;io.reactivex:rxandroid:1.0.1&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.2&apos;</span><br></pre></td></tr></table></figure>
<h4 id="要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致"><a href="#要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致" class="headerlink" title="要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致"></a>要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致</h4><h3 id="b、登录Service"><a href="#b、登录Service" class="headerlink" title="b、登录Service"></a>b、登录Service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface BaseService &#123;</span><br><span class="line">  @GET(&quot;user/login&quot; )</span><br><span class="line">  Observable&lt;User&gt; login(</span><br><span class="line">          @Query(&quot;username&quot;) String username,</span><br><span class="line">          @Query(&quot;password&quot;) String password</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="login方法的返回值是Observable类型，就是RxJava中的被观察者。"><a href="#login方法的返回值是Observable类型，就是RxJava中的被观察者。" class="headerlink" title="login方法的返回值是Observable类型，就是RxJava中的被观察者。"></a>login方法的返回值是Observable类型，就是RxJava中的被观察者。</h4><h3 id="c、网络请求"><a href="#c、网络请求" class="headerlink" title="c、网络请求"></a>c、网络请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create()           .addCallAdapterFactory(RxJavaCallAdapterFactory.create())//新的配置</span><br><span class="line">            .baseUrl(BASE_URL)</span><br><span class="line">            .build();</span><br><span class="line">      BaseService service = retrofit.create(BaseService.class);</span><br><span class="line"></span><br><span class="line">      service.login(phone, password)               //获取Observable对象</span><br><span class="line">              .subscribeOn(Schedulers.newThread())//请求在新的线程中执行</span><br><span class="line">              .observeOn(Schedulers.io())         //请求完成后在io线程中执行</span><br><span class="line">              .doOnNext(new Action1&lt;UserInfo&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void call(User user) &#123;</span><br><span class="line">                      saveUserInfo(user);//保存用户信息到本地</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行</span><br><span class="line">              .subscribe(new Subscriber&lt;User&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void onCompleted() &#123;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  @Override</span><br><span class="line">                  public void onError(Throwable e) &#123;</span><br><span class="line">                      //请求失败</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  @Override</span><br><span class="line">                  public void onNext(User user) &#123;</span><br><span class="line">                      //请求成功</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="RxJava-Retrofit-形式的时候，Retrofit-把请求封装进-Observable-，在请求结束后调用-onNext-或在请求失败后调用-onError-。"><a href="#RxJava-Retrofit-形式的时候，Retrofit-把请求封装进-Observable-，在请求结束后调用-onNext-或在请求失败后调用-onError-。" class="headerlink" title="RxJava + Retrofit 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。"></a>RxJava + Retrofit 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。</h4><h4 id="可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError-、请求成功onNext-。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。"><a href="#可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError-、请求成功onNext-。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。" class="headerlink" title="可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError()、请求成功onNext()。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。"></a>可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError()、请求成功onNext()。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。</h4><pre><code>注意：Retrofit在创建的时候添了一下代码
addCallAdapterFactory(RxJavaCallAdapterFactory.create())
</code></pre><h4 id="想了解更多关于RxJava，浏览http-gank-io-post-560e15be2dca930e00da1083-toc-1"><a href="#想了解更多关于RxJava，浏览http-gank-io-post-560e15be2dca930e00da1083-toc-1" class="headerlink" title="想了解更多关于RxJava，浏览http://gank.io/post/560e15be2dca930e00da1083#toc_1"></a>想了解更多关于RxJava，浏览<a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1" target="_blank" rel="noopener">http://gank.io/post/560e15be2dca930e00da1083#toc_1</a></h4><hr>
<h2 id="11、其他三方"><a href="#11、其他三方" class="headerlink" title="11、其他三方"></a>11、其他三方</h2><h4 id="在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；"><a href="#在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；" class="headerlink" title="在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；"></a>在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；</h4><h4 id="也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；"><a href="#也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；" class="headerlink" title="也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；"></a>也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；</h4><h4 id="就不再一一列举，附上一张图，大家有时间多去学习、多去了解。"><a href="#就不再一一列举，附上一张图，大家有时间多去学习、多去了解。" class="headerlink" title="就不再一一列举，附上一张图，大家有时间多去学习、多去了解。"></a>就不再一一列举，附上一张图，大家有时间多去学习、多去了解。</h4><p><img src="http://img.blog.csdn.net/20170911110309338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h2 id="12、混淆、加固、上线"><a href="#12、混淆、加固、上线" class="headerlink" title="12、混淆、加固、上线"></a>12、混淆、加固、上线</h2><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>大家可以参考我的另一篇文章<a href="http://blog.csdn.net/jiashuai94/article/details/77991077" target="_blank" rel="noopener">http://blog.csdn.net/jiashuai94/article/details/77991077</a></p>
<h4 id="混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。"><a href="#混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。" class="headerlink" title="混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。"></a>混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。</h4><h4 id="坚持以下几项原则："><a href="#坚持以下几项原则：" class="headerlink" title="坚持以下几项原则："></a>坚持以下几项原则：</h4><ul>
<li>使用三方依赖，在混淆文件中添加官方提供的混淆代码，官方没有就google；</li>
<li>实体类不混淆，因为实体类涉及到与服务端的交互，各种gson的交互如此等等，是要保留的；</li>
<li>与js互调的类不混淆；</li>
<li><p>与反射有关的类不混淆 等。</p>
<h4 id="具体语法："><a href="#具体语法：" class="headerlink" title="具体语法："></a>具体语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-optimizationpasses 5 // 代码混淆的压缩比例，值在0-7之间</span><br><span class="line">-dontusemixedcaseclassnames // 混淆后类名都为小写</span><br><span class="line">-dontskipnonpubliclibraryclasses // 指定不去忽略非公共的库的类</span><br><span class="line">-dontskipnonpubliclibraryclassmembers // 指定不去忽略非公共的库的类的成员</span><br><span class="line">-dontpreverify // 不做预校验的操作</span><br><span class="line"></span><br><span class="line">-verbose</span><br><span class="line">-printmapping proguardMapping.txt // 生成原类名和混淆后的类名的映射文件</span><br><span class="line"></span><br><span class="line">-optimizations !code/simplification/cast,!field/*,!class/merging/* // 指定混淆时采用的算法</span><br><span class="line">-keepattributes *Annotation*,InnerClasses // 不混淆Annotation</span><br><span class="line">-keepattributes Signature // 不混淆泛型</span><br><span class="line">-keepattributes SourceFile,LineNumberTable // 抛出异常时保留代码行号</span><br><span class="line">-keep class XXXX // 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。</span><br><span class="line">-keepclasseswithmembers class XXXX // 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="加固："><a href="#加固：" class="headerlink" title="加固："></a>加固：</h3><h4 id="加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。"><a href="#加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。" class="headerlink" title="加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。"></a>加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。</h4><h4 id="360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的-）"><a href="#360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的-）" class="headerlink" title="360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的..）"></a>360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的..）</h4><h3 id="上线："><a href="#上线：" class="headerlink" title="上线："></a>上线：</h3><h4 id="也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。"><a href="#也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。" class="headerlink" title="也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。"></a>也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。</h4><h4 id="每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。"><a href="#每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。" class="headerlink" title="每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。"></a>每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。</h4><h4 id="发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。"><a href="#发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。" class="headerlink" title="发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。"></a>发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。</h4><h4 id="ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。"><a href="#ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。" class="headerlink" title="ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。"></a>ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。</h4><hr>
<h2 id="13、感谢"><a href="#13、感谢" class="headerlink" title="13、感谢"></a>13、感谢</h2><h4 id="感谢天行数据的数据支持；"><a href="#感谢天行数据的数据支持；" class="headerlink" title="感谢天行数据的数据支持；"></a>感谢天行数据的数据支持；</h4><h4 id="感谢各位博客大佬的支持；"><a href="#感谢各位博客大佬的支持；" class="headerlink" title="感谢各位博客大佬的支持；"></a>感谢各位博客大佬的支持；</h4><h4 id="因为时间、水平有限，文章中有不足或不对的地方，希望大家能够指出，我们一起进步。"><a href="#因为时间、水平有限，文章中有不足或不对的地方，希望大家能够指出，我们一起进步。" class="headerlink" title="因为时间、水平有限，文章中有不足或不对的地方，希望大家能够指出，我们一起进步。"></a>因为时间、水平有限，文章中有不足或不对的地方，希望大家能够指出，我们一起进步。</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4a67429c1092?w=344&amp;h=344&amp;f=jpeg&amp;s=8753" alt="这里写图片描述"></p>
<h3 id="扫描二维码，加入我们，获取更多资讯！"><a href="#扫描二维码，加入我们，获取更多资讯！" class="headerlink" title="扫描二维码，加入我们，获取更多资讯！"></a>扫描二维码，加入我们，获取更多资讯！</h3>
          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/11/手撸Router——解决跨模块下的页面跳转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/手撸Router——解决跨模块下的页面跳转/" itemprop="url">手撸Router——解决跨模块下的页面跳转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-11T00:00:00+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>人之所以能，是相信能。</p>
</blockquote>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>开始模块化开发项目之后，一个很重要的问题就是页面见的跳转问题。</p>
<p>关于模块化发开，可详见我的另一片文章<a href="http://blog.csdn.net/jiashuai94/article/details/78020940" target="_blank" rel="noopener">Android模块化开发探索</a>。</p>
<p>正是由于将项目模块化拆分，各模块之间没有任何依赖关系，也互相不可见，那么从A模块的a界面跳转到B模块的b界面该怎么办呢？</p>
<h2 id="二、跨模块跳转的方法"><a href="#二、跨模块跳转的方法" class="headerlink" title="二、跨模块跳转的方法"></a>二、跨模块跳转的方法</h2><p>这里我们会先介绍这几种常见的跳转方法：</p>
<ol>
<li>显示跳转</li>
<li>隐示跳转</li>
<li>Scheme协议跳转</li>
<li>Router路由表方案</li>
</ol>
<h3 id="2-1-显示跳转"><a href="#2-1-显示跳转" class="headerlink" title="2.1 显示跳转"></a>2.1 显示跳转</h3><p>显示跳转即我们最最常用的跳转方法：使用Intent，传入当前Activity上下文，和目标Activity的class对象即可，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setClass(mContext, GuideActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>显然，这种方法只能是目标Activity可见（Activity在同一个Module下）的时候才可以这样调用。不适合跨模块间的跳转。</p>
<h3 id="2-2-隐示跳转"><a href="#2-2-隐示跳转" class="headerlink" title="2.2 隐示跳转"></a>2.2 隐示跳转</h3><p>我们这里说的隐示跳转，intent不设置class，而是设置Action或者Category。</p>
<p>例如：</p>
<p>在清单文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--网页展示界面--&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.whaty.base.BaseWebViewActivity&quot;</span><br><span class="line">    android:hardwareAccelerated=&quot;true&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">            &lt;action android:name=&quot;com.whaty.base.BaseWebViewActivity&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<p>跳转时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个隐式的 Intent 对象：Action 动作  </span><br><span class="line">Intent intent = new Intent();  </span><br><span class="line">//设置 Intent 的动作为清单中指定的action  </span><br><span class="line">intent.setAction(&quot;com.whaty.base.BaseWebViewActivity&quot;);  </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-scheme跳转"><a href="#2-3-scheme跳转" class="headerlink" title="2.3 scheme跳转"></a>2.3 scheme跳转</h3><p>如果我们为 B 页面定义一个 URI - wsc://home/bbb，然后把共享的 messageModel 拍平序列化成 Json 串，那么 A 只需要拼装一个符合 B 页面 scheme 的跳转协议就可以了。<br>wsc://home/bbb?message={ “name”:”John”, “age”:31, “city”:”New York” } </p>
<p>在清单文件中，配置data属性，设置其host、path、scheme等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.ui.BbbActivity&quot;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=&quot;bbb&quot;</span><br><span class="line">            android:path=&quot;/home&quot;</span><br><span class="line">            android:scheme=&quot;wsc&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>
<p>跳转时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final Uri uri = new Uri.Builder().authority(&quot;wsc&quot;).path(&quot;home/bbb&quot;).appendQueryParameter(&quot;message&quot;, new Gson().toJson(messageModel)).build();</span><br><span class="line">final Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(uri);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>以上的方法，都不是我们想要的，接下来开始介绍我们的Router方案。</p>
<h2 id="三、为什么要用Router"><a href="#三、为什么要用Router" class="headerlink" title="三、为什么要用Router"></a>三、为什么要用Router</h2><p><strong>Google提供了显式和隐式两种原生路由方案。但在模块化开发中，显式Intent存在类直接依赖的问题，造成模块间严重耦合。隐式Intent则需要在Manifest中配置大量路径，导致难以拓展（如进行跳转拦截）。为了解决以上问题，我们需要采用一套更为灵活的Router方案。</strong></p>
<h2 id="四、实现思路"><a href="#四、实现思路" class="headerlink" title="四、实现思路"></a>四、实现思路</h2><p>思路是这样的：</p>
<p>使用注解，为每个目标Activity标注别名。在应用启动时，对所有类进行扫名，将注解过的Activity存于路由表中。</p>
<p>跳转时，在路由表中通过别名获取目标Activity的class对象，使用Intent实现跳转。</p>
<p><img src="http://img.blog.csdn.net/20180110153812614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><h3 id="5-1-自定义注解"><a href="#5-1-自定义注解" class="headerlink" title="5.1 自定义注解"></a>5.1 自定义注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 路由跳转界面  注解</span><br><span class="line"> * Created by jia on 2018/1/10.</span><br><span class="line"> * 人之所以能，是相信能</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE) //注解作用于类型（类，接口，注解，枚举）</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) //运行时保留，运行中可以处理</span><br><span class="line">@Documented // 生成javadoc文件</span><br><span class="line">public @interface Action &#123;</span><br><span class="line"></span><br><span class="line">    String DEFAULT = &quot;js&quot;;</span><br><span class="line"></span><br><span class="line">    String value() default DEFAULT;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于自定义注解的详细介绍，请阅读我的文章<a href="http://blog.csdn.net/jiashuai94/article/details/79013000" target="_blank" rel="noopener">java进阶之自定义注解</a>。这里不再多说。</p>
<h3 id="5-2-注解Activity"><a href="#5-2-注解Activity" class="headerlink" title="5.2 注解Activity"></a>5.2 注解Activity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Action(&quot;MainActivity&quot;)</span><br><span class="line">public class MainActivity extends BaseActivity implements TabLayout.OnTabSelectedListener &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建Activity时，用刚刚自定义的注解进行注解，为其注释别名。</p>
<h3 id="5-3-启动时扫描"><a href="#5-3-启动时扫描" class="headerlink" title="5.3 启动时扫描"></a>5.3 启动时扫描</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void getAllActivities(Context ctx)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //通过资源路径获得DexFile</span><br><span class="line">        DexFile e = new DexFile(ctx.getPackageResourcePath());</span><br><span class="line">        Enumeration entries = e.entries();</span><br><span class="line">        //遍历所有元素</span><br><span class="line">        while(entries.hasMoreElements()) &#123;</span><br><span class="line">            String entryName = (String)entries.nextElement();</span><br><span class="line">            //匹配Activity包名与类名</span><br><span class="line">            if(entryName.contains(&quot;activity&quot;) &amp;&amp; entryName.contains(&quot;Activity&quot;)) &#123;</span><br><span class="line">                //通过反射获得Activity类</span><br><span class="line">                Class entryClass = Class.forName(entryName);</span><br><span class="line">                if(entryClass.isAnnotationPresent(Action.class)) &#123;</span><br><span class="line">                    Action action = (Action)entryClass.getAnnotation(Action.class);</span><br><span class="line">                    this.map.put(action.value(), entryClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用启动时，Application中对包下的所有类进行扫描，先找到名字中到activity的（定义到activity包下），并将带有注解标注的Activity，存入map中。</p>
<h3 id="5-4-跳转"><a href="#5-4-跳转" class="headerlink" title="5.4 跳转"></a>5.4 跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 页面跳转</span><br><span class="line"> * @param activity</span><br><span class="line"> * @param alias</span><br><span class="line"> */</span><br><span class="line">public void jumpActivity(Activity activity, String alias) throws ClassNotFoundException&#123;</span><br><span class="line">    if(map.containsKey(alias)) &#123;</span><br><span class="line">        Intent intent = new Intent(activity, map.get(alias));</span><br><span class="line">        activity.startActivity(intent);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳转的时候传入目标Activity的别名即可（这里的别名就是注解的别名）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这种方式，解决了跳转Activity所产生的的模块依赖问题，相较于原生方案，拓展性更强。但这种方案只是阶段性的，还存在一些问题。首先，加载过程中，频繁使用到反射，会产生性能问题。其次，对于每个Activity的别名，需要进行统一维护，增加了协作成本。还有待优化。</p>
<p>当然，市面上有很多流行的Router方案（如阿里的ARouter），这里只是介绍了一个思路，有好的建议欢迎交流，一起进步。</p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shuaijia.github.io/2018/01/05/SurfaceView-MediaPlayer封装之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jia Shuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android机动车">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/05/SurfaceView-MediaPlayer封装之路/" itemprop="url">SurfaceView+MediaPlayer封装之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-05T00:00:00+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SurfaceView-MediaPlayer封装之路"><a href="#SurfaceView-MediaPlayer封装之路" class="headerlink" title="SurfaceView+MediaPlayer封装之路"></a>SurfaceView+MediaPlayer封装之路</h2><p><strong>我的播放器叫做JsPlayer，喜欢的话，就给个star喽^_^<a href="https://github.com/shuaijia/JsPlayer" target="_blank" rel="noopener">https://github.com/shuaijia/JsPlayer</a></strong></p>
<p>这里我只介绍播放器封装思路，会贴出部分代码，如果大家想查看完整代码，可以去github查看，有不清楚或错误或改进的地方，可以issues 我！</p>
<h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>先上效果图：（<strong>1.5版本新增弹幕功能</strong>）</p>
<p><img src="http://img.blog.csdn.net/20170919140145619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170919140242276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170925163230227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="为什么要用SurfaceView"><a href="#为什么要用SurfaceView" class="headerlink" title="为什么要用SurfaceView"></a>为什么要用SurfaceView</h3><p>它继承自类View，因此它本质上是一个View。但与普通View不同的是，它有自己的Surface。而SurfaceView自带一个Surface，这个Surface在WMS中有自己对应的WindowState，在SF中也会有自己的Layer。虽然在App端它仍在View hierachy中，但在Server端（WMS和SF）中，它与宿主窗口是分离的。这样的好处是对这个<strong>Surface的渲染可以放到单独线程</strong>去做，渲染时可以有自己的GL context。这对于一些游戏、视频等性能相关的应用非常有益，因为它不会影响主线程对事件的响应。</p>
<p>SurfaceView内部自己持有surface，surface 创建、销毁、大小改变时系统来处理的，通过surfaceHolder 的callback回调通知。当画布创建好时，可以将surface绑定到MediaPlayer中。SurfaceView如果为用户可见的时候，创建SurfaceView的SurfaceHolder用于显示视频流解析的帧图片，如果发现SurfaceView变为用户不可见的时候，则立即销毁SurfaceView的SurfaceHolder，以达到节约系统资源的目的。</p>
<p>关于更多SurfaceView的介绍，可参考我写的另一片文章：<a href="http://blog.csdn.net/jiashuai94/article/details/77882644" target="_blank" rel="noopener">http://blog.csdn.net/jiashuai94/article/details/77882644</a></p>
<h3 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h3><p>MediaPlayer其实是一个封装的很好的音频、视频流媒体操作类，如果查看其源码，会发现其内部是调用的native方法，所以它其实是有C++实现的。既然是一个流媒体操作类，那么必然涉及到，播放、暂停、停止等操作，实际上MediaPlayer也为我们提供了相应的方法来直接操作流媒体。</p>
<ul>
<li>void statr()：开始或恢复播放。</li>
<li>void stop()：停止播放。</li>
<li>void pause()：暂停播放。　</li>
<li>void setDataSource(String path)：通过一个媒体资源的地址指定MediaPlayer的数据源，这里的path可以是一个本地路径，也可以是网络路径。</li>
</ul>
<p>当然还有其他很多的方法，例如获取视频时长、获取当前位置、定位到某个位置等等方法，就不再一一列举，阅读<strong>JsPlayer</strong>的源码便会有所了解。</p>
<h3 id="播放器结构"><a href="#播放器结构" class="headerlink" title="播放器结构"></a>播放器结构</h3><p><img src="http://img.blog.csdn.net/20170919142258355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="http://img.blog.csdn.net/20170918165320040?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p>已经对SurfaceView+MediaPlayer封装视屏播放器有了大致的了解，接下来就开始视屏播放器的封装之旅吧！</p>
<h2 id="1、工具类"><a href="#1、工具类" class="headerlink" title="1、工具类"></a>1、工具类</h2><p>工欲善其事，必先利其器！</p>
<p>想封装结构清晰，使用方便的视频播放器，工具类是少不了的！JsPlayer主要用了以下几个工具类：</p>
<ul>
<li>DisplayUtils</li>
<li>NetworkUtils</li>
<li>StringUtils</li>
</ul>
<p><strong>DisplayUtils</strong>：负责界面展示相关工具，例如px、dp、sp的相互转换；获取屏幕宽高度；切换横屏、竖屏等；</p>
<p><strong>NetworkUtils</strong>：判断手机是否联网；是否为wifi；是否是流量；网络状态等；</p>
<p><strong>StringUtils</strong>：主要将long型毫秒转换为时间格式的字符串。<br>代码就不贴了，很简单。大家想了解，去github中查看吧。</p>
<hr>
<h2 id="2、实体类"><a href="#2、实体类" class="headerlink" title="2、实体类"></a>2、实体类</h2><p>为了在使用视频播放器时规范传入的数据，同时也方便使用者调用和封装，故定义了视频详情的接口：其包含两个抽象方法，分别返回视频地址和视频标题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 视频数据类</span><br><span class="line"> * 请实现本接口</span><br><span class="line"> */</span><br><span class="line">public interface IVideoInfo extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视频标题</span><br><span class="line">     */</span><br><span class="line">    String getVideoTitle();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视频播放路径（本地或网络）</span><br><span class="line">     */</span><br><span class="line">    String getVideoPath();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户可根据项目实际情况对其进行扩展（<strong>需实现此接口即可</strong>），比如默认图地址，点赞数，是否购买，弹幕信息等等。但<strong>视频标题和视频地址必须返回</strong>！</p>
<hr>
<h2 id="3、回调相关"><a href="#3、回调相关" class="headerlink" title="3、回调相关"></a>3、回调相关</h2><p>大家都知道，VideoView或其他视频播放器在使用时，有准备好监听、播放完成监听、错误监听等等，可供开发者在对应情况进行对应处理；而且我们有时也需要在用户点击播放暂停、全屏、拖动进度条等情况下获得操作回调。因此，我们封装了两个回调接口：</p>
<ul>
<li>OnVideoControlListener：视频控制回调</li>
<li>OnPlayerCallback：视频状态回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 视频控制监听</span><br><span class="line"> */</span><br><span class="line">public interface OnVideoControlListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开始播放按钮</span><br><span class="line">     */</span><br><span class="line">    void onStartPlay();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回</span><br><span class="line">     */</span><br><span class="line">    void onBack();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 全屏</span><br><span class="line">     */</span><br><span class="line">    void onFullScreen();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 错误后的重试</span><br><span class="line">     */</span><br><span class="line">    void onRetry(int errorStatus);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 视频操作回调，是将系统MediaPlayer的常见回调封装</span><br><span class="line"> */</span><br><span class="line">public interface OnPlayerCallback &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 准备好</span><br><span class="line">     */</span><br><span class="line">    void onPrepared(MediaPlayer mp);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视频size变化</span><br><span class="line">     */</span><br><span class="line">    void onVideoSizeChanged(MediaPlayer mp, int width, int height);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存更新变化</span><br><span class="line">     *</span><br><span class="line">     * @param percent 缓冲百分比</span><br><span class="line">     */</span><br><span class="line">    void onBufferingUpdate(MediaPlayer mp, int percent);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 播放完成</span><br><span class="line">     */</span><br><span class="line">    void onCompletion(MediaPlayer mp);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视频错误</span><br><span class="line">     * @param what  错误类型</span><br><span class="line">     * @param extra 特殊错误码</span><br><span class="line">     */</span><br><span class="line">    void onError(MediaPlayer mp, int what, int extra);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视频加载状态变化</span><br><span class="line">     *</span><br><span class="line">     * @param isShow 是否显示loading</span><br><span class="line">     */</span><br><span class="line">    void onLoadingChanged(boolean isShow);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 视频状态变化</span><br><span class="line">     */</span><br><span class="line">    void onStateChanged(int curState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，各位使用上述两个回调时，必须先实现、再使用，当然也可以基于它拓展了！</p>
<hr>
<h2 id="4、自定义view"><a href="#4、自定义view" class="headerlink" title="4、自定义view"></a>4、自定义view</h2><p>关于播放器中涉及到的、需要自定义的view主要有手势调节进度、音量、亮度时的弹框、控制器界面、错误界面。</p>
<p><em>当然我们的JsPlayer视频播放器也是一自定义view，其手势控制也封装了一个view，这些我们稍后会详细介绍。</em></p>
<ul>
<li>JsVideoProgressOverlay：  调节进度 框</li>
<li>JsVideoSystemOverlay：   调节音量、亮度 框</li>
<li>JsVideoErrorView：  错误界面</li>
<li>JsVideoControllerView：  控制器</li>
</ul>
<p>我的思路是这样的：将错误界面JsVideoErrorView再封装到控制器中JsVideoControllerView，这样便于在出错时的处理；而调节进度等弹框、控制器，当然还有SurfaceView，加载中等，它们会一同封装到视频播放器JsPlayer的自定义View中。</p>
<h3 id="JsVideoProgressOverlay"><a href="#JsVideoProgressOverlay" class="headerlink" title="JsVideoProgressOverlay"></a><strong>JsVideoProgressOverlay</strong></h3><p><img src="http://img.blog.csdn.net/20170920141437268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 滑动快进快退进度框</span><br><span class="line"> */</span><br><span class="line">public class JsVideoProgressOverlay extends FrameLayout &#123;</span><br><span class="line"></span><br><span class="line">    private ImageView mSeekIcon;</span><br><span class="line">    private TextView mSeekCurProgress;</span><br><span class="line">    private TextView mSeekDuration;</span><br><span class="line"></span><br><span class="line">    private int mDuration = -1;</span><br><span class="line">    private int mDelSeekDialogProgress = -1;</span><br><span class="line">    private int mSeekDialogStartProgress = -1;</span><br><span class="line"></span><br><span class="line">    public JsVideoProgressOverlay(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JsVideoProgressOverlay(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JsVideoProgressOverlay(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        LayoutInflater.from(getContext()).inflate(R.layout.video_overlay_progress, this);</span><br><span class="line"></span><br><span class="line">        mSeekIcon = (ImageView) findViewById(R.id.iv_seek_direction);</span><br><span class="line">        mSeekCurProgress = (TextView) findViewById(R.id.tv_seek_current_progress);</span><br><span class="line">        mSeekDuration = (TextView) findViewById(R.id.tv_seek_duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 显示进度框</span><br><span class="line">     *</span><br><span class="line">     * @param delProgress 进度变化值</span><br><span class="line">     * @param curPosition player当前进度</span><br><span class="line">     * @param duration    player总长度</span><br><span class="line">     */</span><br><span class="line">    public void show(int delProgress, int curPosition, int duration) &#123;</span><br><span class="line">        if (duration &lt;= 0) return;</span><br><span class="line"></span><br><span class="line">        // 获取第一次显示时的开始进度</span><br><span class="line">        if (mSeekDialogStartProgress == -1) &#123;</span><br><span class="line">            Log.i(&quot;DDD&quot;, &quot;show: start seek = &quot; + mSeekDialogStartProgress);</span><br><span class="line">            mSeekDialogStartProgress = curPosition;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">            setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDuration = duration;</span><br><span class="line">        mDelSeekDialogProgress -= delProgress;</span><br><span class="line">        int targetProgress = getTargetProgress();</span><br><span class="line"></span><br><span class="line">        if (delProgress &gt; 0) &#123;</span><br><span class="line">            // 回退</span><br><span class="line">            mSeekIcon.setImageResource(R.mipmap.ic_video_back);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 前进</span><br><span class="line">            mSeekIcon.setImageResource(R.mipmap.ic_video_speed);</span><br><span class="line">        &#125;</span><br><span class="line">        mSeekCurProgress.setText(StringUtils.stringForTime(targetProgress));</span><br><span class="line">        mSeekDuration.setText(StringUtils.stringForTime(mDuration));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取滑动结束后的目标进度</span><br><span class="line">     */</span><br><span class="line">    public int getTargetProgress() &#123;</span><br><span class="line">        if (mDuration == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int newSeekProgress = mSeekDialogStartProgress + mDelSeekDialogProgress;</span><br><span class="line">        if (newSeekProgress &lt;= 0) newSeekProgress = 0;</span><br><span class="line">        if (newSeekProgress &gt;= mDuration) newSeekProgress = mDuration;</span><br><span class="line">        return newSeekProgress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hide() &#123;</span><br><span class="line">        mDuration = -1;</span><br><span class="line">        mSeekDialogStartProgress = -1;</span><br><span class="line">        mDelSeekDialogProgress = -1;</span><br><span class="line">        setVisibility(GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调节系统属性弹框JsVideoSystemOverlay就不再贴出代码了，与上类似，这里我们只分享设计思路。</p>
<p>注意：</p>
<ul>
<li>mDelSeekDialogProgress -= delProgress，因为向右滑动时传进来的delProgress是负数、向左滑动是正数，所以这里计算变化时是在自减。</li>
<li>if (newSeekProgress &lt;= 0) newSeekProgress = 0;<pre><code>if (newSeekProgress &gt;= mDuration) newSeekProgress = mDuration;
做了边界控制，防止计算出的数据超出范围而导致出错。
</code></pre></li>
</ul>
<h3 id="JsVideoErrorView"><a href="#JsVideoErrorView" class="headerlink" title="JsVideoErrorView"></a><strong>JsVideoErrorView</strong></h3><p><img src="http://img.blog.csdn.net/20170920142641012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从界面来看很简单了！</p>
<p>定义所有错误码常量（可换为枚举）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 正常状态</span><br><span class="line">public static final int STATUS_NORMAL = 0;</span><br><span class="line">// 普通一场</span><br><span class="line">public static final int STATUS_VIDEO_DETAIL_ERROR = 1;</span><br><span class="line">// 资源错误</span><br><span class="line">public static final int STATUS_VIDEO_SRC_ERROR = 2;</span><br><span class="line">// 无WIFI</span><br><span class="line">public static final int STATUS_UN_WIFI_ERROR = 3;</span><br><span class="line">// 无网络</span><br><span class="line">public static final int STATUS_NO_NETWORK_ERROR = 4;</span><br></pre></td></tr></table></figure></p>
<p>另外就是显示的控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (status) &#123;</span><br><span class="line">	case STATUS_VIDEO_DETAIL_ERROR:</span><br><span class="line">		video_error_info.setText(&quot;视频加载失败&quot;);</span><br><span class="line">		video_error_retry.setText(&quot;点此重试&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case STATUS_VIDEO_SRC_ERROR:</span><br><span class="line">		video_error_info.setText(&quot;视频加载失败&quot;);</span><br><span class="line">		video_error_retry.setText(&quot;点此重试&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case STATUS_NO_NETWORK_ERROR:</span><br><span class="line">		video_error_info.setText(&quot;网络连接异常，请检查网络设置后重试&quot;);</span><br><span class="line">		video_error_retry.setText(&quot;重试&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case STATUS_UN_WIFI_ERROR:</span><br><span class="line">		video_error_info.setText(&quot;温馨提示：您正在使用非WiFi网络，播放将产生流量费用&quot;);</span><br><span class="line">		video_error_retry.setText(&quot;继续播放&quot;);</span><br><span class="line">		break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对重试按钮的点击事件：错误view内置了视频控制回调OnVideoControlListener，点击重试时执行回调的重试按钮。</p>
<h3 id="JsVideoControllerView"><a href="#JsVideoControllerView" class="headerlink" title="JsVideoControllerView"></a><strong>JsVideoControllerView</strong></h3><p>先看布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include</span><br><span class="line">        android:id=&quot;@+id/video_controller_bottom&quot;</span><br><span class="line">        layout=&quot;@layout/video_controller_bottom&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/player_lock_screen&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">        android:layout_marginLeft=&quot;10dp&quot;</span><br><span class="line">        android:src=&quot;@mipmap/video_unlock&quot;</span><br><span class="line">        android:visibility=&quot;gone&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.jia.jsplayer.view.JsVideoErrorView</span><br><span class="line">        android:id=&quot;@+id/video_controller_error&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include</span><br><span class="line">        android:id=&quot;@+id/video_controller_title&quot;</span><br><span class="line">        layout=&quot;@layout/video_controller_title&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/video_back&quot;</span><br><span class="line">        android:layout_width=&quot;32dp&quot;</span><br><span class="line">        android:layout_height=&quot;44dp&quot;</span><br><span class="line">        android:layout_alignTop=&quot;@id/video_controller_title&quot;</span><br><span class="line">        android:padding=&quot;12dp&quot;</span><br><span class="line">        android:scaleType=&quot;fitCenter&quot;</span><br><span class="line">        android:src=&quot;@mipmap/ic_back_white&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:id=&quot;@+id/rl_pre&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;#000&quot;</span><br><span class="line">        android:visibility=&quot;gone&quot;&gt;</span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=&quot;@+id/iv_pre_play&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:src=&quot;@mipmap/ic_video_play&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>能够看出：主要分为底部控制部分（播放按钮、当前位置、总时长、进度条），头部控制部分（返回键、标题），出错界面、锁屏按钮和填充全屏的默认图。</p>
<p>对控制器来说，我们应该关心这些：<br><img src="http://img.blog.csdn.net/20170920144950780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhc2h1YWk5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>首先我们必须传入MediaPlayer对象（关于它的封装稍后会详细介绍），因为我们各点击事件和拖动事件都在控制MediaPlayer，如播放按钮的点击事件，在控制视频的播放与暂停，进度条拖动完时，应控制视频定位 等。</p>
<p>注意：</p>
<ul>
<li>对UI的更新全部提出方法，方便其他地方调用</li>
<li>是否锁屏、控制器显示时长等都应有默认值</li>
<li>显示控制器时，视频当前位置和更新的精度</li>
<li>对全屏按钮、重试按钮的点击交给OnVideoControlListener来做</li>
</ul>
<p>我想着重讲一下<strong>控制器的隐藏和显示</strong>：</p>
<h4 id="1、控制器一显示，就获取MediaPlayer的当前位置，更新UI（进度条，当前播放位置），并将当前位置返回："><a href="#1、控制器一显示，就获取MediaPlayer的当前位置，更新UI（进度条，当前播放位置），并将当前位置返回：" class="headerlink" title="1、控制器一显示，就获取MediaPlayer的当前位置，更新UI（进度条，当前播放位置），并将当前位置返回："></a>1、控制器一显示，就获取MediaPlayer的当前位置，更新UI（进度条，当前播放位置），并将当前位置返回：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置进度，同时也返回进度</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int setProgress() &#123;</span><br><span class="line">    if (mPlayer == null || mDragging) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int position = mPlayer.getCurrentPosition();</span><br><span class="line">    int duration = mPlayer.getDuration();</span><br><span class="line">    if (mPlayerSeekBar != null) &#123;</span><br><span class="line">        if (duration &gt; 0) &#123;</span><br><span class="line">            // use long to avoid overflow</span><br><span class="line">            long pos = 1000L * position / duration;</span><br><span class="line">            mPlayerSeekBar.setProgress((int) pos);</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置缓冲进度</span><br><span class="line">        int percent = mPlayer.getBufferPercentage();</span><br><span class="line">        mPlayerSeekBar.setSecondaryProgress(percent * 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVideoProgress.setText(StringUtils.stringForTime(position));</span><br><span class="line">    mVideoDuration.setText(StringUtils.stringForTime(duration));</span><br><span class="line"></span><br><span class="line">    return position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、控制各UI布局显示，开始发送消息"><a href="#2、控制各UI布局显示，开始发送消息" class="headerlink" title="2、控制各UI布局显示，开始发送消息"></a>2、控制各UI布局显示，开始发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 显示控制器</span><br><span class="line"> *</span><br><span class="line"> * @param timeout 显示时长</span><br><span class="line"> */</span><br><span class="line">public void show(int timeout) &#123;</span><br><span class="line">    setProgress();</span><br><span class="line"></span><br><span class="line">    if (!isScreenLock) &#123;</span><br><span class="line">        mControllerBack.setVisibility(VISIBLE);</span><br><span class="line">        mControllerTitle.setVisibility(VISIBLE);</span><br><span class="line">        mControllerBottom.setVisibility(VISIBLE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!DisplayUtils.isPortrait(getContext())) &#123;</span><br><span class="line">            mControllerBack.setVisibility(GONE);</span><br><span class="line">        &#125;</span><br><span class="line">        mControllerTitle.setVisibility(GONE);</span><br><span class="line">        mControllerBottom.setVisibility(GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!DisplayUtils.isPortrait(getContext())) &#123;</span><br><span class="line">        mScreenLock.setVisibility(VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mShowing = true;</span><br><span class="line"></span><br><span class="line">    updatePausePlay();</span><br><span class="line"></span><br><span class="line">    // 开始显示</span><br><span class="line">    post(mShowProgress);</span><br><span class="line"></span><br><span class="line">    if (timeout &gt; 0) &#123;</span><br><span class="line">        // 先移除之前的隐藏异步操作</span><br><span class="line">        removeCallbacks(mFadeOut);</span><br><span class="line">        //timeout后隐藏</span><br><span class="line">        postDelayed(mFadeOut, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步操作隐藏</span><br><span class="line"> */</span><br><span class="line">private final Runnable mFadeOut = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        hide();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步操作显示</span><br><span class="line"> */</span><br><span class="line">private final Runnable mShowProgress = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int pos = setProgress();</span><br><span class="line">        if (!mDragging &amp;&amp; mShowing &amp;&amp; mPlayer.isPlaying()) &#123;</span><br><span class="line">            // 解决1秒之内的误差，使得发送消息正好卡在整秒</span><br><span class="line">            Log.e(&quot;TAG&quot;, &quot;run: &quot; + (1000 - (pos % 1000)));</span><br><span class="line">            postDelayed(mShowProgress, 1000 - (pos % 1000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>首先注意，每当开始发送消息，都应强制将之前的消息全部移除；</strong></li>
<li><strong>发送两个消息：一个是计时的消息，每隔大约一秒获取当前位置并且更新UI，另一个是延迟显示时长后隐藏控制器；</strong></li>
<li><strong>为什么每隔大约1秒更新一次UI呢，postDelayed(mShowProgress, 1000 - (pos % 1000)); 我做了一个修正操作，因为各消息可能会互相影响，其次就是发送消息时没有卡在视频的整秒位置上，而我们确实整1秒发送一条消息，会导致误差！</strong></li>
</ul>
<p>如果大家还想了解其他功能，可以去github阅读我的源码<a href="https://github.com/shuaijia/JsPlayer" target="_blank" rel="noopener">https://github.com/shuaijia/JsPlayer</a></p>
<hr>
<h2 id="5、MediaPlayer封装"><a href="#5、MediaPlayer封装" class="headerlink" title="5、MediaPlayer封装"></a>5、MediaPlayer封装</h2><p>主要封装了</p>
<ul>
<li>openVideo：播放视频，处理各回调</li>
<li>start：开始播放</li>
<li>pause：暂停播放</li>
<li>seekTo：定位到</li>
<li>reset：视频重置</li>
<li>stop：停止播放</li>
<li>isPlaying：是否正在播放</li>
<li>getDuration：获取总时长</li>
<li>getCurrentPosition：获取当前进度</li>
<li>getBufferPercentage：获取缓冲进度 等</li>
</ul>
<p>定义了视频播放的所用状态值常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//出错状态</span><br><span class="line">public static final int STATE_ERROR = -1;</span><br><span class="line">//通常状态</span><br><span class="line">public static final int STATE_IDLE = 0;</span><br><span class="line">//视频正在准备</span><br><span class="line">public static final int STATE_PREPARING = 1;</span><br><span class="line">//视频已经准备好</span><br><span class="line">public static final int STATE_PREPARED = 2;</span><br><span class="line">//视频正在播放</span><br><span class="line">public static final int STATE_PLAYING = 3;</span><br><span class="line">//视频暂停</span><br><span class="line">public static final int STATE_PAUSED = 4;</span><br><span class="line">//视频播放完成</span><br><span class="line">public static final int STATE_PLAYBACK_COMPLETED = 5;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 播放核心使用MediaPlayer</span><br><span class="line">private MediaPlayer player;</span><br><span class="line">// 当前状态</span><br><span class="line">private int curState = STATE_IDLE;</span><br><span class="line">// 当前缓冲进度</span><br><span class="line">private int currentBufferPercentage;</span><br><span class="line">// *视频路径</span><br><span class="line">private String path;</span><br><span class="line"></span><br><span class="line">// 播放监听</span><br><span class="line">private OnPlayerCallback onPlayerListener;</span><br><span class="line">// 播放视频承载的view</span><br><span class="line">private SurfaceHolder surfaceHolder;</span><br></pre></td></tr></table></figure>
<p>封装了视频播放状态的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInPlaybackState() &#123;</span><br><span class="line">    return (player != null &amp;&amp;</span><br><span class="line">            curState != STATE_ERROR &amp;&amp;</span><br><span class="line">            curState != STATE_IDLE &amp;&amp;</span><br><span class="line">            curState != STATE_PREPARING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法会在其他的所有方法执行之前判断，如果返回false，则不进行开始播放、重新播放、拖动定位等操作。</p>
<p>同时这些操作执行完后都会更新当前播放状态，防止视频不能播的情况下操作报错。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开始播放</span><br><span class="line"> */</span><br><span class="line">public void start() &#123;</span><br><span class="line">    if (isInPlaybackState()) &#123;</span><br><span class="line">        player.start();</span><br><span class="line">        setCurrentState(STATE_PLAYING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在openVideo中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public void openVideo() &#123;</span><br><span class="line">    if (path == null || surfaceHolder == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset();</span><br><span class="line"></span><br><span class="line">    player = new MediaPlayer();</span><br><span class="line"></span><br><span class="line">    // 准备好的监听</span><br><span class="line">    player.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onPrepared(MediaPlayer mp) &#123;</span><br><span class="line">            //因为后面播放时要判断当前视频状态，所以在此一定要先将状态改变为STATE_PREPARED</span><br><span class="line">            //即已经准备好，否则在第一次打开视频时无法自动播放</span><br><span class="line">            setCurrentState(STATE_PREPARED);</span><br><span class="line">            if (onPlayerListener != null) &#123;</span><br><span class="line">                onPlayerListener.onPrepared(mp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 缓冲监听</span><br><span class="line">    player.setOnBufferingUpdateListener(new MediaPlayer.OnBufferingUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onBufferingUpdate(MediaPlayer mp, int percent) &#123;</span><br><span class="line">            if (onPlayerListener != null) &#123;</span><br><span class="line">                onPlayerListener.onBufferingUpdate(mp, percent);</span><br><span class="line">            &#125;</span><br><span class="line">            currentBufferPercentage = percent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 播放完成监听</span><br><span class="line">    player.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompletion(MediaPlayer mp) &#123;</span><br><span class="line">            if (onPlayerListener != null) &#123;</span><br><span class="line">                onPlayerListener.onCompletion(mp);</span><br><span class="line">            &#125;</span><br><span class="line">            setCurrentState(STATE_PLAYBACK_COMPLETED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 信息监听</span><br><span class="line">    player.setOnInfoListener(new MediaPlayer.OnInfoListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onInfo(MediaPlayer mp, int what, int extra) &#123;</span><br><span class="line">            if (onPlayerListener != null) &#123;</span><br><span class="line">                // 701 加载中</span><br><span class="line">                if (what == MediaPlayer.MEDIA_INFO_BUFFERING_START) &#123;</span><br><span class="line">                    onPlayerListener.onLoadingChanged(true);</span><br><span class="line">                    // 702 加载完成</span><br><span class="line">                &#125; else if (what == MediaPlayer.MEDIA_INFO_BUFFERING_END) &#123;</span><br><span class="line">                    onPlayerListener.onLoadingChanged(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 出错监听</span><br><span class="line">    player.setOnErrorListener(onErrorListener);</span><br><span class="line">    // 视频大小切换监听</span><br><span class="line">    player.setOnVideoSizeChangedListener(new MediaPlayer.OnVideoSizeChangedListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123;</span><br><span class="line">            if (onPlayerListener != null) &#123;</span><br><span class="line">                onPlayerListener.onVideoSizeChanged(mp, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    currentBufferPercentage = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 在这里开始真正的播放</span><br><span class="line">         */</span><br><span class="line">        player.setDataSource(path);</span><br><span class="line">        player.setDisplay(surfaceHolder);</span><br><span class="line">        player.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">        player.setScreenOnWhilePlaying(true);</span><br><span class="line">        player.prepareAsync();</span><br><span class="line">        Log.e(TAG, &quot;openVideo: &quot; );</span><br><span class="line">        setCurrentState(STATE_PREPARING);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;openVideo: &quot; + e.toString());</span><br><span class="line">        setCurrentState(STATE_ERROR);</span><br><span class="line">        onErrorListener.onError(player, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>openVideo就是播放视频的核心方法：新建MediaPlayer对象；将视频播放的各回调交给OnPlayerCallback处理；将外部传进来的SurfaceHolder设置给MediaPlayer，并且prepareAsync之后就可以播放了，当然，不要忘了更新状态！</p>
<blockquote>
<p>SurfaceHolder是surface的抽象接口，使你可以控制surface的大小和格式， 以及在surface上编辑像素，和监视surace的改变。<br>SurfaceHolder用于显示视频流解析的帧图片，如果发现SurfaceView变为用户不可见的时候，则立即销毁SurfaceView的SurfaceHolder，以达到节约系统资源的目的。</p>
</blockquote>
<hr>
<h2 id="6、手势控制"><a href="#6、手势控制" class="headerlink" title="6、手势控制"></a>6、手势控制</h2><p>说到手势控制，主要是手势控制视频进度，手势控制音量和屏幕亮度。</p>
<p>对于手势控制，我自定义了BehaviorView：让其实现GestureDetector的OnGestureListener</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class VideoBehaviorView extends FrameLayout implements GestureDetector.OnGestureListener&#123;</span><br></pre></td></tr></table></figure>
<p>在此view中定义以下方法，<strong>实现更新UI，交由子类去复写</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 更新进度UI，由子类重写</span><br><span class="line">protected void updateSeekUI(int delProgress) &#123;</span><br><span class="line">    // sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新音量UI，由子类重写</span><br><span class="line">protected void updateVolumeUI(int max, int progress) &#123;</span><br><span class="line">    // sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新亮度UI，由子类重写</span><br><span class="line">protected void updateLightUI(int max, int progress) &#123;</span><br><span class="line">    // sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的思路是将view的<strong>触摸事件全部交给GestureDetector处理</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    mGestureDetector.onTouchEvent(event);</span><br><span class="line">    switch (event.getAction() &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">        case MotionEvent.ACTION_OUTSIDE:</span><br><span class="line">        case MotionEvent.ACTION_CANCEL:</span><br><span class="line">            endGesture(mFingerBehavior);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当手指按下时，重置手指行为，获取当前音量、亮度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onDown(MotionEvent e) &#123;</span><br><span class="line">    //重置 手指行为</span><br><span class="line">    mFingerBehavior = -1;</span><br><span class="line">    mCurrentVolume = am.getStreamVolume(AudioManager.STREAM_MUSIC);</span><br><span class="line">    try &#123;</span><br><span class="line">        mCurrentBrightness = (int) (activity.getWindow().getAttributes().screenBrightness * mMaxBrightness);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onScroll方法中:</p>
<p>判断决定当前为何种类型手势：左右滑动为调节进度，左半屏上下滑动为调节亮度，右半屏上下滑动为调节音量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据手势起始2个点断言 后续行为. 规则如下:</span><br><span class="line"> *  屏幕切分为:</span><br><span class="line"> *  1.左右扇形区域为视频进度调节</span><br><span class="line"> *  2.上下扇形区域 左半屏亮度调节 后半屏音量调节.</span><br><span class="line"> */</span><br><span class="line">if (mFingerBehavior &lt; 0) &#123;</span><br><span class="line">    float moveX = e2.getX() - e1.getX();</span><br><span class="line">    float moveY = e2.getY() - e1.getY();</span><br><span class="line">    // 如果横向滑动距离大于纵向滑动距离，则认为在调节进度</span><br><span class="line">    if (Math.abs(moveX) &gt;= Math.abs(moveY))</span><br><span class="line">        mFingerBehavior = FINGER_BEHAVIOR_PROGRESS;</span><br><span class="line">        // 否则为调节音量或亮度</span><br><span class="line">        // 按下位置在屏幕左半边，则是调节亮度</span><br><span class="line">    else if (e1.getX() &lt;= width / 2) mFingerBehavior = FINGER_BEHAVIOR_BRIGHTNESS;</span><br><span class="line">        // 按下位置在屏幕右半边，则是在调节音量</span><br><span class="line">    else mFingerBehavior = FINGER_BEHAVIOR_VOLUME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手势处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">switch (mFingerBehavior) &#123;</span><br><span class="line">    case FINGER_BEHAVIOR_PROGRESS: &#123; // 进度变化</span><br><span class="line">        // 默认滑动一个屏幕 视频移动八分钟.</span><br><span class="line">        int delProgress = (int) (1.0f * distanceX / width * 480 * 1000);</span><br><span class="line">        // 更新快进弹框</span><br><span class="line">        updateSeekUI(delProgress);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case FINGER_BEHAVIOR_VOLUME: &#123; // 音量变化</span><br><span class="line">        float progress = mMaxVolume * (distanceY / height) + mCurrentVolume;</span><br><span class="line"></span><br><span class="line">        // 控制调节临界范围</span><br><span class="line">        if (progress &lt;= 0) progress = 0;</span><br><span class="line">        if (progress &gt;= mMaxVolume) progress = mMaxVolume;</span><br><span class="line"></span><br><span class="line">        am.setStreamVolume(AudioManager.STREAM_MUSIC, Math.round(progress), 0);</span><br><span class="line">        updateVolumeUI(mMaxVolume, Math.round(progress));</span><br><span class="line">        // 更新当前值</span><br><span class="line">        mCurrentVolume = progress;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case FINGER_BEHAVIOR_BRIGHTNESS: &#123; // 亮度变化</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果系统亮度为自动调节，则改为手动调节</span><br><span class="line">            if (Settings.System.getInt(getContext().getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE)</span><br><span class="line">                    == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) &#123;</span><br><span class="line">                Settings.System.putInt(getContext().getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE,</span><br><span class="line">                        Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int progress = (int) (mMaxBrightness * (distanceY / height) + mCurrentBrightness);</span><br><span class="line"></span><br><span class="line">            // 控制调节临界范围</span><br><span class="line">            if (progress &lt;= 0) progress = 0;</span><br><span class="line">            if (progress &gt;= mMaxBrightness) progress = mMaxBrightness;</span><br><span class="line"></span><br><span class="line">            Window window = activity.getWindow();</span><br><span class="line">            WindowManager.LayoutParams params = window.getAttributes();</span><br><span class="line">            params.screenBrightness = progress / (float) mMaxBrightness;</span><br><span class="line">            window.setAttributes(params);</span><br><span class="line"></span><br><span class="line">            updateLightUI(mMaxBrightness, progress);</span><br><span class="line">            // 更新当前值</span><br><span class="line">            mCurrentBrightness = progress;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><strong>所有的更新UI操作全部交由子类实现</strong></li>
<li><strong>注意临界范围的控制</strong></li>
<li><strong>控制进度时，百分比最后乘以8分钟，以达到较为适中的用户体验</strong>，防止视频时长过大或太小情况下，拖动调节进度变化太过明显或效果不明显。</li>
</ul>
<hr>
<h2 id="7、播放器JsPlayer封装"><a href="#7、播放器JsPlayer封装" class="headerlink" title="7、播放器JsPlayer封装"></a>7、播放器JsPlayer封装</h2><p>先来看看布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;SurfaceView</span><br><span class="line">        android:id=&quot;@+id/video_surface&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.jia.jsplayer.view.JsVideoControllerView</span><br><span class="line">        android:id=&quot;@+id/video_controller&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include</span><br><span class="line">        android:id=&quot;@+id/video_loading&quot;</span><br><span class="line">        layout=&quot;@layout/video_controller_loading&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.jia.jsplayer.view.JsVideoSystemOverlay</span><br><span class="line">        android:id=&quot;@+id/video_system_overlay&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:visibility=&quot;gone&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.jia.jsplayer.view.JsVideoProgressOverlay</span><br><span class="line">        android:id=&quot;@+id/video_progress_overlay&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:visibility=&quot;gone&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>JsPlayer视频播放器集成自上一步中的VideoBehaviorView，注意复写VideoBehaviorView的更新UI方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private SurfaceView surfaceView;</span><br><span class="line">private View loadingView;</span><br><span class="line">private JsVideoProgressOverlay progressView;</span><br><span class="line">private JsVideoSystemOverlay systemView;</span><br><span class="line">private JsVideoControllerView mediaController;</span><br><span class="line"></span><br><span class="line">private JsMediaPlayer mMediaPlayer;</span><br></pre></td></tr></table></figure>
<p>内置封装过得JsMediaPlayer 对象，控制器、和SurfaceView，还有网络状态广播接收器。</p>
<p>初始化player，创建JsMediaPlayer对象，设置视频播放回调处理，然后将其设置给ControllerView。</p>
<p>注意：</p>
<ul>
<li>在准备好的监听中，mediaPlayer执行开始播放，控制器展示，错误界面隐藏。</li>
<li>在播放出错时控制器检查错误类型并展示</li>
<li>在加载状态发生改变时隐藏和展示加载中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private void initPlayer() &#123;</span><br><span class="line">    mMediaPlayer = new JsMediaPlayer();</span><br><span class="line"></span><br><span class="line">    // todo 这里可以优化，将这些回调全部暴露出去</span><br><span class="line">    mMediaPlayer.setOnPlayerListener(new OnPlayerCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onPrepared(MediaPlayer mp) &#123;</span><br><span class="line">            Log.e(TAG, &quot;onPrepared: &quot; );</span><br><span class="line">            mMediaPlayer.start();</span><br><span class="line">            mediaController.show();</span><br><span class="line">            mediaController.hideErrorView();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onBufferingUpdate(MediaPlayer mp, int percent) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompletion(MediaPlayer mp) &#123;</span><br><span class="line">            mediaController.updatePausePlay();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(MediaPlayer mp, int what, int extra) &#123;</span><br><span class="line">            mediaController.checkShowError(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onLoadingChanged(boolean isShow) &#123;</span><br><span class="line">            if (isShow) showLoading();</span><br><span class="line">            else hideLoading();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onStateChanged(int curState) &#123;</span><br><span class="line">            switch (curState) &#123;</span><br><span class="line">                case JsMediaPlayer.STATE_IDLE:</span><br><span class="line">                    am.abandonAudioFocus(null);</span><br><span class="line">                    break;</span><br><span class="line">                case JsMediaPlayer.STATE_PREPARING:</span><br><span class="line">                    am.requestAudioFocus(null, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mediaController.setMediaPlayer(mMediaPlayer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>给SurfaceView设置Callback，返回SurfaceHolder后设置给JsMediaPlayer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">        Log.e(TAG, &quot;surfaceCreated: &quot; );</span><br><span class="line">        initWidth = getWidth();</span><br><span class="line">        initHeight = getHeight();</span><br><span class="line"></span><br><span class="line">        if (mMediaPlayer != null) &#123;</span><br><span class="line">            mMediaPlayer.setSurfaceHolder(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>设置路径，开始播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void setPath(final IVideoInfo video) &#123;</span><br><span class="line">    if (video == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMediaPlayer.reset();</span><br><span class="line"></span><br><span class="line">    String videoPath = video.getVideoPath();</span><br><span class="line">    mediaController.setVideoInfo(video);</span><br><span class="line">    mMediaPlayer.setPath(videoPath);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void startPlay()&#123;</span><br><span class="line">    mMediaPlayer.openVideo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新UI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void updateSeekUI(int delProgress) &#123;</span><br><span class="line">    progressView.show(delProgress, mMediaPlayer.getCurrentPosition(), mMediaPlayer.getDuration());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void updateVolumeUI(int max, int progress) &#123;</span><br><span class="line">    systemView.show(JsVideoSystemOverlay.SystemType.VOLUME, max, progress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void updateLightUI(int max, int progress) &#123;</span><br><span class="line">    systemView.show(JsVideoSystemOverlay.SystemType.BRIGHTNESS, max, progress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然不会忘记封装播放、暂停、停止、定位、获取总时长等等的基本方法，这里就不再累赘。</p>
<hr>
<h2 id="8、使用"><a href="#8、使用" class="headerlink" title="8、使用"></a>8、使用</h2><h3 id="涉及到播放网路视频，权限少不了"><a href="#涉及到播放网路视频，权限少不了" class="headerlink" title="涉及到播放网路视频，权限少不了"></a>涉及到播放网路视频，权限少不了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>播放本地视频别忘了6.0权限适配</strong></p>
<h3 id="布局中添加"><a href="#布局中添加" class="headerlink" title="布局中添加"></a>布局中添加</h3><h3 id="代码中"><a href="#代码中" class="headerlink" title="代码中"></a>代码中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">player = (JsPlayer) findViewById(R.id.player);</span><br><span class="line"></span><br><span class="line">player.setOnVideoControlListener(new OnVideoControlListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartPlay() &#123;</span><br><span class="line">        player.startPlay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFullScreen() &#123;</span><br><span class="line">        DisplayUtils.toggleScreenOrientation(MainActivity.this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onRetry(int errorStatus) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">player.setPath(new VideoInfo(&quot;艺术人生&quot;, path));</span><br></pre></td></tr></table></figure>
<h3 id="生命周期绑定"><a href="#生命周期绑定" class="headerlink" title="生命周期绑定"></a>生命周期绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onStop() &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    player.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    player.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全屏操作"><a href="#全屏操作" class="headerlink" title="全屏操作"></a>全屏操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class="line">    super.onConfigurationChanged(newConfig);</span><br><span class="line">    if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line">    &#125; else if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onBackPressed() &#123;</span><br><span class="line">    if (!DisplayUtils.isPortrait(this)) &#123;</span><br><span class="line">        if (!player.isLock()) &#123;</span><br><span class="line">            DisplayUtils.toggleScreenOrientation(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意所在Activity在清单文件中应设置<strong>android:configChanges=”orientation|keyboardHidden|screenSize”</strong></p>
<h3 id="这样就ok了，播放器封装完美完成！"><a href="#这样就ok了，播放器封装完美完成！" class="headerlink" title="这样就ok了，播放器封装完美完成！"></a>这样就ok了，播放器封装完美完成！</h3><p>###希望对大家有所帮助！</p>

          
        
      
    </div>
    
    
    

    

    

    
	
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jia Shuai</p>
              <p class="site-description motion-element" itemprop="description">贾帅的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shuaijia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/jiashuai94" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jia Shuai</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
